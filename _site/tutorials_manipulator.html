<!DOCTYPE html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="keywords" content=" sample">
<title>Manipulator | DART Website</title>
<link rel="stylesheet" href="css/syntax.css">


<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
<!--<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">-->
<link rel="stylesheet" href="css/modern-business.css">
<link rel="stylesheet" href="css/lavish-bootstrap.css">
<link rel="stylesheet" href="css/customstyles.css">
<link rel="stylesheet" href="css/theme-blue.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="js/jquery.navgoco.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/2.0.0/anchor.min.js"></script>
<script src="js/toc.js"></script>
<script src="js/customscripts.js"></script>

<link rel="shortcut icon" href="images/favicon.ico">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link rel="alternate" type="application/rss+xml" title="" href="http://idratherbewriting.comfeed.xml">

    <script>
        $(document).ready(function() {
            // Initialize navgoco with default options
            $("#mysidebar").navgoco({
                caretHtml: '',
                accordion: true,
                openClass: 'active', // open
                save: false, // leave false or nav highlighting doesn't work right
                cookie: {
                    name: 'navgoco',
                    expires: false,
                    path: '/'
                },
                slide: {
                    duration: 400,
                    easing: 'swing'
                }
            });

            $("#collapseAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', false);
            });

            $("#expandAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', true);
            });

        });

    </script>
    <script>
        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        })
    </script>
    

</head>
<body>
<!-- Navigation -->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="fa fa-home fa-lg navbar-brand" href="index.html">&nbsp;<span class="projectTitle"> DART</span></a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- entries without drop-downs appear here -->
                
                
                
                <li><a href="tutorials_introduction.html">Tutorials</a></li>
                
                
                
                <!-- entries with drop-downs appear here -->
                <!-- conditional logic to control which topnav appears for the audience defined in the configuration file.-->
                
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Github<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="http://github.com/dartsim/dart" target="_blank">View Project on Github</a></li>
                        
                        
                        
                        <li><a href="https://github.com/dartsim/dart/issues" target="_blank">Report Issue</a></li>
                        
                        
                    </ul>
                </li>
                
                
                
			<li><a class="email" title="Submit feedback" href="#" onclick="javascript:window.location='mailto:jslee02@gmail.com?subject=DART feedback f eedback&body=I have some feedback about the Manipulator page: ' + window.location.href;"><i class="fa fa-envelope-o"></i> Feedback</a><li>

		
                <!--comment out this block if you want to hide search-->
                <li>
                    <!--start search-->
                    <div id="search-demo-container">
                        <input type="text" id="search-input" placeholder="search...">
                        <ul id="results-container"></ul>
                    </div>
                    <script src="js/jekyll-search.js" type="text/javascript"></script>
                    <script type="text/javascript">
                            SimpleJekyllSearch.init({
                                searchInput: document.getElementById('search-input'),
                                resultsContainer: document.getElementById('results-container'),
                                dataSource: 'search.json',
                                searchResultTemplate: '<li><a href="{url}" title="Manipulator">{title}</a></li>',
                    noResultsText: 'No results found.',
                            limit: 10,
                            fuzzy: true,
                    })
                    </script>
                    <!--end search-->
                </li>
            </ul>
        </div>
        </div>
        <!-- /.container -->
</nav>

<!-- Page Content -->
<div class="container">
    <div class="col-lg-12">&nbsp;</div>
    <!-- Content Row -->
    <div class="row">
        <!-- Sidebar Column -->
        <div class="col-md-3">

          












<ul id="mysidebar" class="nav">
    <li class="sidebarTitle">DART Tutorials 6.1.0</li>
    
    
    
        
    
    <li>
        <a href="#">Tutorials</a>
        <ul>
            
            
            
            <li><a href="tutorials_introduction.html">Introduction</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_pendulum.html">Pendulum</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_collisions.html">Collisions</a></li>
            
            
            
            
            
            
            <li class="active"><a href="tutorials_manipulator.html">Manipulator</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_biped.html">Biped</a></li>
            
            
            
            
        </ul>
        
        
        
        <!-- if you aren't using the accordion, uncomment this block:
           <p class="external">
               <a href="#" id="collapseAll">Collapse All</a> | <a href="#" id="expandAll">Expand All</a>
           </p>
           -->
    </li>
</ul>
</div>

<!-- this highlights the active parent class in the navgoco sidebar. this is critical so that the parent expands when you're viewing a page. This must appear below the sidebar code above. Otherwise, if placed inside customscripts.js, the script runs before the sidebar code runs and the class never gets inserted.-->
<script>$("li.active").parents('li').toggleClass("active");</script>

    <!-- Content Column -->
    <div class="col-md-9">
        <div class="post-header">
   <h1 class="post-title-main">Manipulator</h1>
</div>



<div class="post-content">

   

    
    
<!-- this handles the automatic toc. use ## for subheads to auto-generate the on-page minitoc. if you use html tags, you must supply an ID for the heading element in order for it to appear in the minitoc. -->
<script>
$( document ).ready(function() {
  // Handler for .ready() called.

$('#toc').toc({ minimumHeaders: 0, listType: 'ul', showSpeed: 0, headers: 'h2,h3,h4' });

/* this offset helps account for the space taken up by the floating toolbar. */
$('#toc').on('click', 'a', function() {
  var target = $(this.getAttribute('href'))
    , scroll_target = target.offset().top

  $(window).scrollTop(scroll_target - 10);
  return false
})
  
});
</script>

<div id="toc"></div>

    

    

    

    <a target="_blank" href="https://github.com/tomjohnson1492/documentation-theme-jekyll/blob/gh-pages/pages//_pages/tutorials/tutorials_manipulator.html.md" class="btn btn-default githubEditButton" role="button"><i class="fa fa-github fa-lg"></i> Edit me</a>
    

    

  <h2 id="overview">Overview</h2>

<p>This tutorial will demonstrate some of the more advanced features of DART’s
dynamics API which allow you to write robust controllers that work for real
dynamic systems, such as robotic manipulators. We will show you how to:</p>

<ul>
  <li>Clone Skeletons</li>
  <li>Load a URDF</li>
  <li>Write a stable PD controller w/ gravity and coriolis compensation</li>
  <li>Write an operational space controller</li>
</ul>

<p>Please reference the source code in <a href="https://github.com/dartsim/dart/blob/release-5.1/tutorials/tutorialDominoes.cpp"><strong>tutorialDominoes.cpp</strong></a> and <a href="https://github.com/dartsim/dart/blob/release-5.1/tutorials/tutorialDominoes-Finished.cpp"><strong>tutorialDominoes-Finished.cpp</strong></a>.</p>

<h2 id="lesson-1-cloning-skeletons">Lesson 1: Cloning Skeletons</h2>

<p>There are often times where you might want to create an exact replica of an
existing Skeleton. DART offers cloning functionality that allows you to do this
very easily.</p>

<h3 id="lesson-1a-create-a-new-domino">Lesson 1a: Create a new domino</h3>

<p>Creating a new domino is straightforward. Find the function <code class="highlighter-rouge">attemptToCreateDomino</code>
in the <code class="highlighter-rouge">MyWindow</code> class. The class has a member called <code class="highlighter-rouge">mFirstDomino</code> which
is the original domino created when the program starts up. To make a new one,
we can just clone it:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SkeletonPtr</span> <span class="n">newDomino</span> <span class="o">=</span> <span class="n">mFirstDomino</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
</code></pre>
</div>

<p>But keep in mind that every Skeleton that gets added to a world requires its own
unique name. Creating a clone will keep the original name, so we should we give
the new copy its own name:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">newDomino</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="s">"domino #"</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">mDominoes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</code></pre>
</div>

<p>So the easy part is finished, but now we need to get the domino to the correct
position. First, let’s grab the last domino that was placed in the environment:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="n">SkeletonPtr</span><span class="o">&amp;</span> <span class="n">lastDomino</span> <span class="o">=</span> <span class="n">mDominoes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span>
      <span class="n">mDominoes</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">:</span> <span class="n">mFirstDomino</span><span class="p">;</span>
</code></pre>
</div>

<p>Now we should compute what we want its position to be. The <code class="highlighter-rouge">MyWindow</code> class
keeps a member called <code class="highlighter-rouge">mTotalAngle</code> which tracks how much the line of dominoes
has turned so far. We’ll use that to figure out what translational offset the
new domino should have from the last domino:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">default_distance</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span>
      <span class="n">cos</span><span class="p">(</span><span class="n">mTotalAngle</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">mTotalAngle</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</code></pre>
</div>

<p>And now we can compute the total position of the new domino. First, we’ll copy
the positions of the last domino:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">x</span> <span class="o">=</span> <span class="n">lastDomino</span><span class="o">-&gt;</span><span class="n">getPositions</span><span class="p">();</span>
</code></pre>
</div>

<p>And then we’ll add the translational offset to it:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">x</span><span class="p">.</span><span class="n">tail</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+=</span> <span class="n">dx</span><span class="p">;</span>
</code></pre>
</div>

<p>Remember that the domino’s root joint is a FreeJoint which has six degrees of
freedom: the first three are for orientation and last three are for translation.</p>

<p>Finally, we should add on the change in angle for the new domino:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mTotalAngle</span> <span class="o">+</span> <span class="n">angle</span><span class="p">;</span>
</code></pre>
</div>

<p>Be sure to uncomment the <code class="highlighter-rouge">angle</code> argument of the function.</p>

<p>Now we can use <code class="highlighter-rouge">x</code> to set the positions of the domino:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">newDomino</span><span class="o">-&gt;</span><span class="n">setPositions</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre>
</div>

<p>The root FreeJoint is the only joint in the domino’s Skeleton, so we can just
use the <code class="highlighter-rouge">Skeleton::setPositions</code> function to set it.</p>

<p>Now we’ll add the Skeleton to the world:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mWorld</span><span class="o">-&gt;</span><span class="n">addSkeleton</span><span class="p">(</span><span class="n">newDomino</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="lesson-1b-make-sure-no-dominoes-are-in-collision">Lesson 1b: Make sure no dominoes are in collision</h3>

<p>Similar to <strong>Lesson 3</strong> of the <strong>Collisions</strong> tutorial, we’ll want to make sure
that the newly inserted Skeleton is not starting out in collision with anything,
because this could make for a very ugly (perhaps even broken) simulation.</p>

<p>First, we’ll tell the world to compute collisions:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">dart</span><span class="o">::</span><span class="n">collision</span><span class="o">::</span><span class="n">CollisionDetector</span><span class="o">*</span> <span class="n">detector</span> <span class="o">=</span>
    <span class="n">mWorld</span><span class="o">-&gt;</span><span class="n">getConstraintSolver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getCollisionDetector</span><span class="p">();</span>
<span class="n">detector</span><span class="o">-&gt;</span><span class="n">detectCollision</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</code></pre>
</div>

<p>Now we’ll look through and see if any dominoes are in collision with anything
besides the floor. We ignore collisions with the floor because, mathemetically
speaking, if they are in contact with the floor then they register as being in
collision. But we want the dominoes to be in contact with the floor, so this is
okay.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">dominoCollision</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">collisionCount</span> <span class="o">=</span> <span class="n">detector</span><span class="o">-&gt;</span><span class="n">getNumContacts</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">collisionCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// If neither of the colliding BodyNodes belongs to the floor, then we
</span>  <span class="c1">// know the new domino is in contact with something it shouldn't be
</span>  <span class="k">const</span> <span class="n">dart</span><span class="o">::</span><span class="n">collision</span><span class="o">::</span><span class="n">Contact</span><span class="o">&amp;</span> <span class="n">contact</span> <span class="o">=</span> <span class="n">detector</span><span class="o">-&gt;</span><span class="n">getContact</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">contact</span><span class="p">.</span><span class="n">bodyNode1</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSkeleton</span><span class="p">()</span> <span class="o">!=</span> <span class="n">mFloor</span>
     <span class="o">&amp;&amp;</span> <span class="n">contact</span><span class="p">.</span><span class="n">bodyNode2</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSkeleton</span><span class="p">()</span> <span class="o">!=</span> <span class="n">mFloor</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">dominoCollision</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The only object that could possibly have collided with something else is the
new domino, because we don’t allow the application to create new things except
for the dominoes. So if this registered as true, then we should take the new
domino out of the world:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">dominoCollision</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Remove the new domino, because it is penetrating an existing one
</span>  <span class="n">mWorld</span><span class="o">-&gt;</span><span class="n">removeSkeleton</span><span class="p">(</span><span class="n">newDomino</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Otherwise, if the new domino is in an okay position, we should add it to the
history:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">else</span>
<span class="p">{</span>
  <span class="c1">// Record the latest domino addition
</span>  <span class="n">mAngles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>
  <span class="n">mDominoes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newDomino</span><span class="p">);</span>
  <span class="n">mTotalAngle</span> <span class="o">+=</span> <span class="n">angle</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="lesson-1c-delete-the-last-domino-added">Lesson 1c: Delete the last domino added</h3>

<p>Ordinarily, removing a Skeleton from a scene is just a matter of calling the
<code class="highlighter-rouge">World::removeSkeleton</code> function, but we have a little bit of bookkeeping to
take care of for our particular application. First, we should check whether
there are any dominoes to actually remove:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">mDominoes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: Remove Skeleton
</span><span class="p">}</span>
</code></pre>
</div>

<p>Then we should grab the last domino in the history, remove it from the history,
and then take it out of the world:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SkeletonPtr</span> <span class="n">lastDomino</span> <span class="o">=</span> <span class="n">mDominoes</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="n">mDominoes</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="n">mWorld</span><span class="o">-&gt;</span><span class="n">removeSkeleton</span><span class="p">(</span><span class="n">lastDomino</span><span class="p">);</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">SkeletonPtr</code> class is really a <code class="highlighter-rouge">std::shared_ptr&lt;Skeleton&gt;</code> so we don’t
need to worry about ever calling <code class="highlighter-rouge">delete</code> on it. Instead, its resources will
be freed when <code class="highlighter-rouge">lastDomino</code> goes out of scope.</p>

<p>We should also make sure to do the bookkeepping for the angles:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mTotalAngle</span> <span class="o">-=</span> <span class="n">mAngles</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="n">mAngles</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</code></pre>
</div>

<p><strong>Now we can add and remove dominoes from the scene. Feel free to give it a try.</strong></p>

<h3 id="lesson-1d-apply-a-force-to-the-first-domino">Lesson 1d: Apply a force to the first domino</h3>

<p>But just setting up dominoes isn’t much fun without being able to knock them
down. We can quickly and easily knock down the dominoes by magically applying
a force to the first one. In the <code class="highlighter-rouge">timeStepping</code> function of <code class="highlighter-rouge">MyWindow</code> there
is a label for <strong>Lesson 1d</strong>. This spot will get visited whenever the user
presses ‘f’, so we’ll apply an external force to the first domino here:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">force</span> <span class="o">=</span> <span class="n">default_push_force</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">UnitX</span><span class="p">();</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">location</span> <span class="o">=</span>
    <span class="n">default_domino_height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">UnitZ</span><span class="p">();</span>
<span class="n">mFirstDomino</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addExtForce</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="lesson-2-loading-and-controlling-a-robotic-manipulator">Lesson 2: Loading and controlling a robotic manipulator</h2>

<p>Striking something with a magical force is convenient, but not very believable.
Instead, let’s load a robotic manipulator and have it push over the first domino.</p>

<h3 id="lesson-2a-load-a-urdf-file">Lesson 2a: Load a URDF file</h3>

<p>Our manipulator is going to be loaded from a URDF file. URDF files are loaded
by the <code class="highlighter-rouge">dart::utils::DartLoader</code> class (pending upcoming changes to DART’s
loading system). First, create a loader:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">dart</span><span class="o">::</span><span class="n">utils</span><span class="o">::</span><span class="n">DartLoader</span> <span class="n">loader</span><span class="p">;</span>
</code></pre>
</div>

<p>Note that many URDF files use ROS’s <code class="highlighter-rouge">package:</code> scheme to specify the locations
of the resources that need to be loaded. We won’t be using this in our example,
but in general you should use the function <code class="highlighter-rouge">DartLoader::addPackageDirectory</code>
to specify the locations of these packages, because DART does not have the same
package resolving abilities of ROS.</p>

<p>Now we’ll have <code class="highlighter-rouge">loader</code> parse the file into a Skeleton:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SkeletonPtr</span> <span class="n">manipulator</span> <span class="o">=</span>
    <span class="n">loader</span><span class="p">.</span><span class="n">parseSkeleton</span><span class="p">(</span><span class="n">DART_DATA_PATH</span><span class="s">"urdf/KR5/KR5 sixx R650.urdf"</span><span class="p">);</span>
</code></pre>
</div>

<p>And we should give the Skeleton a convenient name:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">manipulator</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="s">"manipulator"</span><span class="p">);</span>
</code></pre>
</div>

<p>Now we’ll want to initialize the location and configuration of the manipulator.
Experimentation has demonstrated that the following setup is good for our purposes:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Position its base in a reasonable way
</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span> <span class="n">tf</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">tf</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="o">-</span><span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="n">manipulator</span><span class="o">-&gt;</span><span class="n">getJoint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setTransformFromParentBodyNode</span><span class="p">(</span><span class="n">tf</span><span class="p">);</span>

<span class="c1">// Get it into a useful configuration
</span><span class="n">manipulator</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="mf">140.0</span> <span class="o">*</span> <span class="n">M_PI</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">);</span>
<span class="n">manipulator</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="o">-</span><span class="mf">140.0</span> <span class="o">*</span> <span class="n">M_PI</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">);</span>
</code></pre>
</div>

<p>And lastly, be sure to return the Skeleton that we loaded rather than the dummy
Skeleton that was originally there:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">return</span> <span class="n">manipulator</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>Feel free to load up the application to see the manipulator in the scene,
although all it will be able to do is collapse pitifully onto the floor.</strong></p>

<h3 id="lesson-2b-grab-the-desired-joint-angles">Lesson 2b: Grab the desired joint angles</h3>

<p>To make the manipulator actually useful, we’ll want to have the <code class="highlighter-rouge">Controller</code>
control its joint forces. For it to do that, the <code class="highlighter-rouge">Controller</code> class will need
to be informed of what we want the manipulator’s joint angles to be. This is 
easily done in the constructor of the <code class="highlighter-rouge">Controller</code> class:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mQDesired</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getPositions</span><span class="p">();</span>
</code></pre>
</div>

<p>The function <code class="highlighter-rouge">Skeleton::getPositions</code> will get all the generalized coordinate
positions of all the joints in the Skeleton, stacked in a single vector. These
Skeleton API functions are useful when commanding or controlling an entire
Skeleton with a single mathematical expression.</p>

<h3 id="lesson-2c-write-a-stable-pd-controller-for-the-manipulator">Lesson 2c: Write a stable PD controller for the manipulator</h3>

<p>Now that we know what configuration we want the manipulator to hold, we can
write a PD controller that keeps them in place. Find the function <code class="highlighter-rouge">setPDForces</code>
in the <code class="highlighter-rouge">Controller</code> class.</p>

<p>First, we’ll grab the current positions and velocities:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getPositions</span><span class="p">();</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getVelocities</span><span class="p">();</span>
</code></pre>
</div>

<p>Additionally, we’ll integrate the position forward by one timestep:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">q</span> <span class="o">+=</span> <span class="n">dq</span> <span class="o">*</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getTimeStep</span><span class="p">();</span>
</code></pre>
</div>

<p>This is not necessary for writing a regular PD controller, but instead this is
to write a “stable PD” controller which has some better numerical stability
properties than an ordinary discrete PD controller. You can try running with and
without this line to see what effect it has on the stability.</p>

<p>Now we’ll compute our joint position error:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">q_err</span> <span class="o">=</span> <span class="n">mQDesired</span> <span class="o">-</span> <span class="n">q</span><span class="p">;</span>
</code></pre>
</div>

<p>And our joint velocity error, assuming our desired joint velocity is zero:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">dq_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">dq</span><span class="p">;</span>
</code></pre>
</div>

<p>Now we can grab our mass matrix, which we will use to scale our force terms:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&amp;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getMassMatrix</span><span class="p">();</span>
</code></pre>
</div>

<p>And then combine all this into a PD controller that computes forces to minimize
our error:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mForces</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="p">(</span><span class="n">mKpPD</span> <span class="o">*</span> <span class="n">q_err</span> <span class="o">+</span> <span class="n">mKdPD</span> <span class="o">*</span> <span class="n">dq_err</span><span class="p">);</span>
</code></pre>
</div>

<p>Now we’re ready to set these forces on the manipulator:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">setForces</span><span class="p">(</span><span class="n">mForces</span><span class="p">);</span>
</code></pre>
</div>

<p><strong>Feel free to give this PD controller a try to see how effective it is.</strong></p>

<h3 id="lesson-2d-compensate-for-gravity-and-coriolis-forces">Lesson 2d: Compensate for gravity and Coriolis forces</h3>

<p>One of the key features of DART is the ability to easily compute the gravity and
Coriolis forces, allowing you to write much higher quality controllers than you
would be able to otherwise. This is easily done like so:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="o">&amp;</span> <span class="n">Cg</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getCoriolisAndGravityForces</span><span class="p">();</span>
</code></pre>
</div>

<p>And now we can update our control law by just slapping this term onto the end
of the equation:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mForces</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="p">(</span><span class="n">mKpPD</span> <span class="o">*</span> <span class="n">q_err</span> <span class="o">+</span> <span class="n">mKdPD</span> <span class="o">*</span> <span class="n">dq_err</span><span class="p">)</span> <span class="o">+</span> <span class="n">Cg</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>Give this new PD controller a try to see how its performance compares to the
one without compensation</strong></p>

<h2 id="lesson-3-writing-an-operational-space-controller">Lesson 3: Writing an operational space controller</h2>

<p>While PD controllers are simply and handy, operational space controllers can be
much more elegant and useful for performing tasks. Operational space controllers
allow us to unify geometric tasks (like getting the end effector to a particular
spot) and dynamics tasks (like applying a certain force with the end effector)
all while remaining stable and smooth.</p>

<h3 id="lesson-3a-set-up-the-information-needed-for-an-os-controller">Lesson 3a: Set up the information needed for an OS controller</h3>

<p>Unlike PD controllers, an operational space controller needs more information
than just desired joint angles.</p>

<p>First, we’ll grab the last BodyNode on the manipulator and treat it as an end
effector:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mEndEffector</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getNumBodyNodes</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>But we don’t want to use the origin of the BodyNode frame as the origin of our
Operational Space controller; instead we want to use a slight offset, to get to
the tool area of the last BodyNode:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mOffset</span> <span class="o">=</span> <span class="n">default_endeffector_offset</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">UnitX</span><span class="p">();</span>
</code></pre>
</div>

<p>Also, our target will be the spot on top of the first domino, so we’ll create a
reference frame and place it there. First, create the SimpleFrame:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mTarget</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SimpleFrame</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Frame</span><span class="o">::</span><span class="n">World</span><span class="p">(),</span> <span class="s">"target"</span><span class="p">);</span>
</code></pre>
</div>

<p>Then compute the transform needed to get from the center of the domino to the
top of the domino:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span> <span class="n">target_offset</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span><span class="o">::</span><span class="n">Identity</span><span class="p">());</span>
<span class="n">target_offset</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span> <span class="o">=</span>
    <span class="n">default_domino_height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">UnitZ</span><span class="p">();</span>
</code></pre>
</div>

<p>And then we should rotate the target’s coordinate frame to make sure that lines
up with the end effector’s reference frame, otherwise the manipulator might try
to push on the domino from a very strange angle:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">target_offset</span><span class="p">.</span><span class="n">linear</span><span class="p">()</span> <span class="o">=</span>
    <span class="n">mEndEffector</span><span class="o">-&gt;</span><span class="n">getTransform</span><span class="p">(</span><span class="n">domino</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)).</span><span class="n">linear</span><span class="p">();</span>
</code></pre>
</div>

<p>Now we’ll set the target so that it has a transform of <code class="highlighter-rouge">target_offset</code> with
respect to the frame of the domino:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mTarget</span><span class="o">-&gt;</span><span class="n">setTransform</span><span class="p">(</span><span class="n">target_offset</span><span class="p">,</span> <span class="n">domino</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</code></pre>
</div>

<p>And this gives us all the information we need to write an Operational Space
controller.</p>

<h3 id="lesson-3b-computing-forces-for-os-controller">Lesson 3b: Computing forces for OS Controller</h3>

<p>Find the function <code class="highlighter-rouge">setOperationalSpaceForces()</code>. This is where we’ll compute
the forces for our operational space controller.</p>

<p>One of the key ingredients in an operational space controller is the mass matrix.
We can get this easily, just like we did for the PD controller:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&amp;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getMassMatrix</span><span class="p">();</span>
</code></pre>
</div>

<p>Next we’ll want the Jacobian of the tool offset in the end effector. We can get
it easily with this function:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Jacobian</span> <span class="n">J</span> <span class="o">=</span> <span class="n">mEndEffector</span><span class="o">-&gt;</span><span class="n">getWorldJacobian</span><span class="p">(</span><span class="n">mOffset</span><span class="p">);</span>
</code></pre>
</div>

<p>But operational space controllers typically use the Moore-Penrose pseudoinverse
of the Jacobian rather than the Jacobian itself. There are many ways to compute
the pseudoinverse of the Jacobian, but a simple way is like this:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">pinv_J</span> <span class="o">=</span> <span class="n">J</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="n">J</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span>
                       <span class="o">+</span> <span class="mf">0.0025</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix6d</span><span class="o">::</span><span class="n">Identity</span><span class="p">()).</span><span class="n">inverse</span><span class="p">();</span>
</code></pre>
</div>

<p>Note that this pseudoinverse is also damped so that it behaves better around
singularities. This is method for computing the pseudoinverse is not very
efficient in terms of the number of mathematical operations it performs, but
it is plenty fast for our application. Consider using methods based on Singular
Value Decomposition if you need to compute the pseudoinverse as fast as possible.</p>

<p>Next we’ll want the time derivative of the Jacobian, as well as its pseudoinverse:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// Compute the Jacobian time derivative
</span><span class="n">Jacobian</span> <span class="n">dJ</span> <span class="o">=</span> <span class="n">mEndEffector</span><span class="o">-&gt;</span><span class="n">getJacobianClassicDeriv</span><span class="p">(</span><span class="n">mOffset</span><span class="p">);</span>

<span class="c1">// Comptue the pseudo-inverse of the Jacobian time derivative
</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">pinv_dJ</span> <span class="o">=</span> <span class="n">dJ</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">dJ</span> <span class="o">*</span> <span class="n">dJ</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span>
                        <span class="o">+</span> <span class="mf">0.0025</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix6d</span><span class="o">::</span><span class="n">Identity</span><span class="p">()).</span><span class="n">inverse</span><span class="p">();</span>
</code></pre>
</div>

<p>Notice that here we’re compute the <strong>classic</strong> derivative, which means the
derivative of the Jacobian with respect to time in classical coordinates rather
than spatial coordinates. If you use spatial vector arithmetic, then you’ll want
to use <code class="highlighter-rouge">BodyNode::getJacobianSpatialDeriv</code> instead.</p>

<p>Now we can compute the linear components of error:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">e</span><span class="p">;</span>
<span class="n">e</span><span class="p">.</span><span class="n">tail</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">mTarget</span><span class="o">-&gt;</span><span class="n">getWorldTransform</span><span class="p">().</span><span class="n">translation</span><span class="p">()</span>
            <span class="o">-</span> <span class="n">mEndEffector</span><span class="o">-&gt;</span><span class="n">getWorldTransform</span><span class="p">()</span> <span class="o">*</span> <span class="n">mOffset</span><span class="p">;</span>
</code></pre>
</div>

<p>And then the angular components of error:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxisd</span> <span class="n">aa</span><span class="p">(</span><span class="n">mTarget</span><span class="o">-&gt;</span><span class="n">getTransform</span><span class="p">(</span><span class="n">mEndEffector</span><span class="p">).</span><span class="n">linear</span><span class="p">());</span>
<span class="n">e</span><span class="p">.</span><span class="n">head</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">aa</span><span class="p">.</span><span class="n">angle</span><span class="p">()</span> <span class="o">*</span> <span class="n">aa</span><span class="p">.</span><span class="n">axis</span><span class="p">();</span>
</code></pre>
</div>

<p>Then the time derivative of error, assuming our desired velocity is zero:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">de</span> <span class="o">=</span> <span class="o">-</span><span class="n">mEndEffector</span><span class="o">-&gt;</span><span class="n">getSpatialVelocity</span><span class="p">(</span>
      <span class="n">mOffset</span><span class="p">,</span> <span class="n">mTarget</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">Frame</span><span class="o">::</span><span class="n">World</span><span class="p">());</span>
</code></pre>
</div>

<p>Like with the PD controller, we can mix in terms to compensate for gravity and
Coriolis forces:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="o">&amp;</span> <span class="n">Cg</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getCoriolisAndGravityForces</span><span class="p">();</span>
</code></pre>
</div>

<p>The gains for the operational space controller need to be in matrix form, but
we’re storing the gains as scalars, so we’ll need to conver them:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix6d</span> <span class="n">Kp</span> <span class="o">=</span> <span class="n">mKpOS</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix6d</span><span class="o">::</span><span class="n">Identity</span><span class="p">();</span>

<span class="kt">size_t</span> <span class="n">dofs</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getNumDofs</span><span class="p">();</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">Kd</span> <span class="o">=</span> <span class="n">mKdOS</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">::</span><span class="n">Identity</span><span class="p">(</span><span class="n">dofs</span><span class="p">,</span> <span class="n">dofs</span><span class="p">);</span>
</code></pre>
</div>

<p>And we’ll need to compute the joint forces needed to achieve our desired end
effector force. This is easily done using the Jacobian transpose:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span> <span class="n">fDesired</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector6d</span><span class="o">::</span><span class="n">Zero</span><span class="p">();</span>
<span class="n">fDesired</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_push_force</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">f</span> <span class="o">=</span> <span class="n">J</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">fDesired</span><span class="p">;</span>
</code></pre>
</div>

<p>And now we can mix everything together into the single control law:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">getVelocities</span><span class="p">();</span>
<span class="n">mForces</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="p">(</span><span class="n">pinv_J</span> <span class="o">*</span> <span class="n">Kp</span> <span class="o">*</span> <span class="n">de</span> <span class="o">+</span> <span class="n">pinv_dJ</span> <span class="o">*</span> <span class="n">Kp</span> <span class="o">*</span> <span class="n">e</span><span class="p">)</span>
          <span class="o">-</span> <span class="n">Kd</span> <span class="o">*</span> <span class="n">dq</span> <span class="o">+</span> <span class="n">Kd</span> <span class="o">*</span> <span class="n">pinv_J</span> <span class="o">*</span> <span class="n">Kp</span> <span class="o">*</span> <span class="n">e</span> <span class="o">+</span> <span class="n">Cg</span> <span class="o">+</span> <span class="n">f</span><span class="p">;</span>
</code></pre>
</div>

<p>Then don’t forget to pass the forces into the manipulator:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mManipulator</span><span class="o">-&gt;</span><span class="n">setForces</span><span class="p">(</span><span class="n">mForces</span><span class="p">);</span>
</code></pre>
</div>

<p><strong>Now you’re ready to try out the full dominoes app!</strong></p>

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="http://dart.readthedocs.org/en/release-5.1/tutorials/dominoes/" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true"></div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'dartsim';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



    <div class="tags">
        
    </div>

    

</div>

<hr class="shaded"/>

<footer>
            <div class="row">
                <div class="col-lg-12 footer">
               &copy;2016 Georgia Tech and Carnegie Mellon University. All rights reserved. <br />
 Site last generated: Oct 6, 2016 <br />
<p><img src="images/dart_logo_big.jpg" alt="DART logo" style="width:128px"/></p>
                </div>
            </div>
</footer>


    </div>
    <!-- /.row -->
</div>
<!-- /.container -->
    </div>

</body>

</html>