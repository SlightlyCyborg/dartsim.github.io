<!DOCTYPE html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="keywords" content=" sample">
<title>Collisions | DART Website</title>
<link rel="stylesheet" href="css/syntax.css">


<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
<!--<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">-->
<link rel="stylesheet" href="css/modern-business.css">
<link rel="stylesheet" href="css/lavish-bootstrap.css">
<link rel="stylesheet" href="css/customstyles.css">
<link rel="stylesheet" href="css/theme-blue.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="js/jquery.navgoco.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/2.0.0/anchor.min.js"></script>
<script src="js/toc.js"></script>
<script src="js/customscripts.js"></script>

<link rel="shortcut icon" href="images/favicon.ico">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link rel="alternate" type="application/rss+xml" title="" href="http://idratherbewriting.comfeed.xml">

    <script>
        $(document).ready(function() {
            // Initialize navgoco with default options
            $("#mysidebar").navgoco({
                caretHtml: '',
                accordion: true,
                openClass: 'active', // open
                save: false, // leave false or nav highlighting doesn't work right
                cookie: {
                    name: 'navgoco',
                    expires: false,
                    path: '/'
                },
                slide: {
                    duration: 400,
                    easing: 'swing'
                }
            });

            $("#collapseAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', false);
            });

            $("#expandAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', true);
            });

        });

    </script>
    <script>
        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        })
    </script>
    

</head>
<body>
<!-- Navigation -->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="fa fa-home fa-lg navbar-brand" href="index.html">&nbsp;<span class="projectTitle"> DART</span></a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- entries without drop-downs appear here -->
                
                
                
                <li><a href="tutorials_introduction.html">Tutorials</a></li>
                
                
                
                <!-- entries with drop-downs appear here -->
                <!-- conditional logic to control which topnav appears for the audience defined in the configuration file.-->
                
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Github<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="http://github.com/dartsim/dart" target="_blank">View Project on Github</a></li>
                        
                        
                        
                        <li><a href="https://github.com/dartsim/dart/issues" target="_blank">Report Issue</a></li>
                        
                        
                    </ul>
                </li>
                
                
                
			<li><a class="email" title="Submit feedback" href="#" onclick="javascript:window.location='mailto:jslee02@gmail.com?subject=DART feedback f eedback&body=I have some feedback about the Collisions page: ' + window.location.href;"><i class="fa fa-envelope-o"></i> Feedback</a><li>

		
                <!--comment out this block if you want to hide search-->
                <li>
                    <!--start search-->
                    <div id="search-demo-container">
                        <input type="text" id="search-input" placeholder="search...">
                        <ul id="results-container"></ul>
                    </div>
                    <script src="js/jekyll-search.js" type="text/javascript"></script>
                    <script type="text/javascript">
                            SimpleJekyllSearch.init({
                                searchInput: document.getElementById('search-input'),
                                resultsContainer: document.getElementById('results-container'),
                                dataSource: 'search.json',
                                searchResultTemplate: '<li><a href="{url}" title="Collisions">{title}</a></li>',
                    noResultsText: 'No results found.',
                            limit: 10,
                            fuzzy: true,
                    })
                    </script>
                    <!--end search-->
                </li>
            </ul>
        </div>
        </div>
        <!-- /.container -->
</nav>

<!-- Page Content -->
<div class="container">
    <div class="col-lg-12">&nbsp;</div>
    <!-- Content Row -->
    <div class="row">
        <!-- Sidebar Column -->
        <div class="col-md-3">

          












<ul id="mysidebar" class="nav">
    <li class="sidebarTitle">DART Tutorials 6.1.0</li>
    
    
    
        
    
    <li>
        <a href="#">Tutorials</a>
        <ul>
            
            
            
            <li><a href="tutorials_introduction.html">Introduction</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_pendulum.html">Pendulum</a></li>
            
            
            
            
            
            
            <li class="active"><a href="tutorials_collisions.html">Collisions</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_manipulator.html">Manipulator</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_biped.html">Biped</a></li>
            
            
            
            
        </ul>
        
        
        
        <!-- if you aren't using the accordion, uncomment this block:
           <p class="external">
               <a href="#" id="collapseAll">Collapse All</a> | <a href="#" id="expandAll">Expand All</a>
           </p>
           -->
    </li>
</ul>
</div>

<!-- this highlights the active parent class in the navgoco sidebar. this is critical so that the parent expands when you're viewing a page. This must appear below the sidebar code above. Otherwise, if placed inside customscripts.js, the script runs before the sidebar code runs and the class never gets inserted.-->
<script>$("li.active").parents('li').toggleClass("active");</script>

    <!-- Content Column -->
    <div class="col-md-9">
        <div class="post-header">
   <h1 class="post-title-main">Collisions</h1>
</div>



<div class="post-content">

   

    
    
<!-- this handles the automatic toc. use ## for subheads to auto-generate the on-page minitoc. if you use html tags, you must supply an ID for the heading element in order for it to appear in the minitoc. -->
<script>
$( document ).ready(function() {
  // Handler for .ready() called.

$('#toc').toc({ minimumHeaders: 0, listType: 'ul', showSpeed: 0, headers: 'h2,h3,h4' });

/* this offset helps account for the space taken up by the floating toolbar. */
$('#toc').on('click', 'a', function() {
  var target = $(this.getAttribute('href'))
    , scroll_target = target.offset().top

  $(window).scrollTop(scroll_target - 10);
  return false
})
  
});
</script>

<div id="toc"></div>

    

    

    

    <a target="_blank" href="https://github.com/tomjohnson1492/documentation-theme-jekyll/blob/gh-pages/pages//_pages/tutorials/tutorials_collisions.html.md" class="btn btn-default githubEditButton" role="button"><i class="fa fa-github fa-lg"></i> Edit me</a>
    

    

  <h2 id="overview">Overview</h2>
<p>This tutorial will show you how to programmatically create different kinds of
bodies and set initial conditions for Skeletons. It will also demonstrate some
use of DART’s Frame Semantics.</p>

<p>The tutorial consists of five Lessons covering the following topics:</p>

<ul>
  <li>Creating a rigid body</li>
  <li>Creating a soft body</li>
  <li>Setting initial conditions and taking advantage of Frames</li>
  <li>Setting joint spring and damping properties</li>
  <li>Creating a closed kinematic chain</li>
</ul>

<p>Please reference the source code in <a href="https://github.com/dartsim/dart/blob/release-6.0/tutorials/tutorialCollisions.cpp"><strong>tutorialCollisions.cpp</strong></a> and <a href="https://github.com/dartsim/dart/blob/release-6.0/tutorials/tutorialCollisions-Finished.cpp"><strong>tutorialCollisions-Finished.cpp</strong></a>.</p>

<h2 id="lesson-1-creating-a-rigid-body">Lesson 1: Creating a rigid body</h2>

<p>Start by going opening the Skeleton code <a href="https://github.com/dartsim/dart/blob/release-6.0/tutorials/tutorialCollisions.cpp">tutorialCollisions.cpp</a>.
Find the function named <code class="highlighter-rouge">addRigidBody</code>. You will notice that this is a templated
function. If you’re not familiar with templates, that’s okay; we won’t be doing
anything too complicated with them. Different Joint types in DART are managed by
a bunch of different classes, so we need to use templates if we want the same
function to work with a variety of Joint types.</p>

<h3 id="lesson-1a-setting-joint-properties">Lesson 1a: Setting joint properties</h3>

<p>The first thing we’ll want to do is set the Joint properties for our new body.
Whenever we create a BodyNode, we must also create a parent Joint for it. A
BodyNode needs a parent Joint, even if that BodyNode is the root of the Skeleton,
because we need its parent Joint to describe how it’s attached to the world. A
root BodyNode could be attached to the world by any kind of Joint. Most often,
it will be attached by either a FreeJoint (if the body should be completely
free to move with respect to the world) or a WeldJoint (if the body should be
rigidly attached to the world, unable to move at all), but <em>any</em> Joint type
is permissible.</p>

<p>Joint properties are managed in a nested class, which means it’s a class which
is defined inside of another class. For example, <code class="highlighter-rouge">RevoluteJoint</code> properties are
managed in a class called <code class="highlighter-rouge">RevoluteJoint::Properties</code> while <code class="highlighter-rouge">PrismaticJoint</code>
properties are managed in a class called <code class="highlighter-rouge">PrismaticJoint::Properties</code>. However,
both <code class="highlighter-rouge">RevoluteJoint</code> and <code class="highlighter-rouge">PrismaticJoint</code> inherit the <code class="highlighter-rouge">SingleDofJoint</code> class
so the <code class="highlighter-rouge">RevoluteJoint::Properties</code> and <code class="highlighter-rouge">PrismaticJoint::Properties</code> classes
both inherit the <code class="highlighter-rouge">SingleDofJoint::Properties</code> class. The difference is that
<code class="highlighter-rouge">RevoluteJoint::Properties</code> also inherits <code class="highlighter-rouge">RevoluteJoint::UniqueProperties</code>
whereas <code class="highlighter-rouge">PrismaticJoint::Properties</code> inherits <code class="highlighter-rouge">PrismaticJoint::UniqueProperties</code>
instead. Many DART classes contain nested <code class="highlighter-rouge">Properties</code> classes like this which
are compositions of their base class’s nested <code class="highlighter-rouge">Properties</code> class and their own
<code class="highlighter-rouge">UniqueProperties</code> class. As you’ll see later, this is useful for providing a
consistent API that works cleanly for fundamentally different types of classes.</p>

<p>To create a <code class="highlighter-rouge">Properties</code> class for our Joint type, we’ll want to say
<code class="highlighter-rouge">cpp
typename JointType::Properties properties;
</code></p>

<p>We need to include the <code class="highlighter-rouge">typename</code> keywords because of how the syntax works for
templated functions. Leaving it out should make your compiler complain.</p>

<p>From here, we can set the Joint properties in any way we’d like. There are only
a few things we care about right now: First, the Joint’s name. Every Joint in a
Skeleton needs to have a non-empty unique name. Those are the only restrictions
that are placed on Joint names. If you try to make a Joint’s name empty, it will
be given a default name. If you try to make a Joint’s name non-unique, DART will
append a number tag to the end of the name in order to make it unique. It will
also print out a warning during run time, which can be an eyesore (because it
wants you to be aware when you are being negligent about naming things). For the
sake of simplicity, let’s just give it a name based off its child BodyNode:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">properties</span><span class="p">.</span><span class="n">mName</span> <span class="o">=</span> <span class="n">name</span><span class="o">+</span><span class="s">"_joint"</span><span class="p">;</span>
</code></pre>
</div>

<p>Don’t forget to uncomment the function arguments.</p>

<p>Next we’ll want to deal with offsetting the new BodyNode from its parent BodyNode.
We can use the following to check if there is a parent BodyNode:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: offset the child from its parent
</span><span class="p">}</span>
</code></pre>
</div>

<p>Inside the brackets, we’ll want to create the offset between bodies:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span> <span class="n">tf</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span><span class="o">::</span><span class="n">Identity</span><span class="p">());</span>
</code></pre>
</div>

<p>An <code class="highlighter-rouge">Eigen::Isometry3d</code> is the Eigen library’s version of a homogeneous
transformation matrix. Here we are initializing it to an Identity matrix to
start out. This is almost always something you should do when creating an
Eigen::Isometry3d, because otherwise its contents will be completely arbitrary
trash.</p>

<p>We can easily compute the center point between the origins of the two bodies
using our default height value:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">tf</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">default_shape_height</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>
</code></pre>
</div>

<p>We can then offset the parent and child BodyNodes of this Joint using this
transform:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">properties</span><span class="p">.</span><span class="n">mT_ParentBodyToJoint</span> <span class="o">=</span> <span class="n">tf</span><span class="p">;</span>
<span class="n">properties</span><span class="p">.</span><span class="n">mT_ChildBodyToJoint</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span>
</code></pre>
</div>

<p>Remember that all of that code should go inside the <code class="highlighter-rouge">if(parent)</code> condition.
We do not want to create this offset for root BodyNodes, because later on we
will rely on the assumption that the root Joint origin is lined up with the
root BodyNode origin.</p>

<h3 id="lesson-1b-create-a-joint-and-bodynode-pair">Lesson 1b: Create a Joint and BodyNode pair</h3>

<p>A single function is used to simultaneously create a new Joint and its child
BodyNode. It’s important to note that a Joint cannot be created without a
child BodyNode to accompany it, and a BodyNode cannot be created with parent
Joint to attach it to something. A parent Joint without a child BodyNode or
vice-versa would be non-physical and nonsensical, so we don’t allow it.</p>

<p>Use the following to create a new Joint &amp; BodyNode, and obtain a pointer to
that new BodyNode:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">BodyNode</span><span class="o">*</span> <span class="n">bn</span> <span class="o">=</span> <span class="n">chain</span><span class="o">-&gt;</span><span class="n">createJointAndBodyNodePair</span><span class="o">&lt;</span><span class="n">JointType</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">parent</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">BodyNode</span><span class="o">::</span><span class="n">AspectProperties</span><span class="p">(</span><span class="n">name</span><span class="p">)).</span><span class="n">second</span><span class="p">;</span>
</code></pre>
</div>

<p>There’s a lot going on in this function, so let’s break it down for a moment:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">chain</span><span class="o">-&gt;</span><span class="n">createJointAndBodyNodePair</span><span class="o">&lt;</span><span class="n">JointType</span><span class="o">&gt;</span>
</code></pre>
</div>

<p>This is a Skeleton member function that takes template arguments. The first
template argument specifies the type of Joint that you want to create. In our
case, the type of Joint we want to create is actually a template argument of
our current function, so we just pass that argument along. The second template
argument of <code class="highlighter-rouge">createJointAndBodyNodePair</code> allows us to specify the BodyNode
type that we want to create, but the default argument is a standard rigid 
BodyNode, so we can leave the second argument blank.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">BodyNode</span><span class="o">::</span><span class="n">AspectProperties</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
</code></pre>
</div>

<p>Now for the function arguments: The first specifies the parent BodyNode. In the
event that you want to create a root BodyNode, you can simply pass in a nullptr
as the parent. The second argument is a <code class="highlighter-rouge">JointType::Properties</code> struct, so we
pass in the <code class="highlighter-rouge">properties</code> object that we created earlier. The third argument is
a <code class="highlighter-rouge">BodyNode::Properties</code> struct, but we’re going to set the BodyNode properties
later, so we’ll just toss the name in by wrapping it up in a
<code class="highlighter-rouge">BodyNode::AspectProperties</code> object and leave the rest as default values.</p>

<p>Now notice the very last thing on this line of code:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</code></pre>
</div>

<p>The function actually returns a <code class="highlighter-rouge">std::pair</code> of pointers to the new Joint and
new BodyNode that were just created, but we only care about grabbing the 
BodyNode once the function is finished, so we can append <code class="highlighter-rouge">.second</code> to the end
of the line so that we just grab the BodyNode pointer and ignore the Joint 
pointer. The joint will of course still be created; we just have no need to 
access it at this point.</p>

<h3 id="lesson-1c-make-a-shape-for-the-body">Lesson 1c: Make a shape for the body</h3>

<p>We’ll take advantage of the Shape::ShapeType enumeration to specify what kind of
Shape we want to produce for the body. In particular, we’ll allow the user to
specify three types of Shapes: <code class="highlighter-rouge">Shape::BOX</code>, <code class="highlighter-rouge">Shape::CYLINDER</code>, and
<code class="highlighter-rouge">Shape::ELLIPSOID</code>.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">ShapePtr</span> <span class="n">shape</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">Shape</span><span class="o">::</span><span class="n">BOX</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: Make a box
</span><span class="p">}</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Shape</span><span class="o">::</span><span class="n">CYLINDER</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: Make a cylinder
</span><span class="p">}</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">SHAPE</span><span class="o">::</span><span class="n">ELLIPSOID</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: Make an ellipsoid
</span><span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">ShapePtr</code> is simply a typedef for <code class="highlighter-rouge">std::shared_ptr&lt;Shape&gt;</code>. DART has this
typedef in order to improve space usage and readability, because this type gets
used very often.</p>

<p>Now we want to construct each of the Shape types within their conditional
statements. Each constructor is a bit different.</p>

<p>For box we pass in an Eigen::Vector3d that contains the three dimensions of the box:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">shape</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoxShape</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span>
                                     <span class="n">default_shape_width</span><span class="p">,</span>
                                     <span class="n">default_shape_width</span><span class="p">,</span>
                                     <span class="n">default_shape_height</span><span class="p">));</span>
</code></pre>
</div>

<p>For cylinder we pass in a radius and a height:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">shape</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">CylinderShape</span><span class="o">&gt;</span><span class="p">(</span><span class="n">default_shape_width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>
                                        <span class="n">default_shape_height</span><span class="p">);</span>
</code></pre>
</div>

<p>For ellipsoid we pass in an Eigen::Vector3d that contains the lengths of the three axes:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">shape</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">EllipsoidShape</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">default_shape_height</span><span class="o">*</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">Ones</span><span class="p">());</span>
</code></pre>
</div>

<p>Since we actually want a sphere, all three axis lengths will be equal, so we can
create an Eigen::Vector3d filled with ones by using <code class="highlighter-rouge">Eigen::Vector3d::Ones()</code>
and then multiply it by the length that we actually want for the three components.</p>

<p>Finally, we want to add this shape as a visualization <strong>and</strong> collision shape for
the BodyNode:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">bn</span><span class="o">-&gt;</span><span class="n">addVisualizationShape</span><span class="p">(</span><span class="n">shape</span><span class="p">);</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">addCollisionShape</span><span class="p">(</span><span class="n">shape</span><span class="p">);</span>
</code></pre>
</div>

<p>We want to do this no matter which type was selected, so those two lines of code
should be after all the condition statements.</p>

<h3 id="lesson-1d-set-up-the-inertia-properties-for-the-body">Lesson 1d: Set up the inertia properties for the body</h3>

<p>For the simulations to be physically accurate, it’s important for the inertia
properties of the body to match up with the geometric properties of the shape.
We can create an <code class="highlighter-rouge">Inertia</code> object and set its values based on the shape’s
geometry, then give that <code class="highlighter-rouge">Inertia</code> to the BodyNode.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Inertia</span> <span class="n">inertia</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">mass</span> <span class="o">=</span> <span class="n">default_shape_density</span> <span class="o">*</span> <span class="n">shape</span><span class="o">-&gt;</span><span class="n">getVolume</span><span class="p">();</span>
<span class="n">inertia</span><span class="p">.</span><span class="n">setMass</span><span class="p">(</span><span class="n">mass</span><span class="p">);</span>
<span class="n">inertia</span><span class="p">.</span><span class="n">setMoment</span><span class="p">(</span><span class="n">shape</span><span class="o">-&gt;</span><span class="n">computeInertia</span><span class="p">(</span><span class="n">mass</span><span class="p">));</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">setInertia</span><span class="p">(</span><span class="n">inertia</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="lesson-1e-set-the-coefficient-of-restitution">Lesson 1e: Set the coefficient of restitution</h3>

<p>This is very easily done with the following function:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">bn</span><span class="o">-&gt;</span><span class="n">setRestitutionCoeff</span><span class="p">(</span><span class="n">default_restitution</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="lesson-1f-set-the-damping-coefficient">Lesson 1f: Set the damping coefficient</h3>

<p>In real life, joints have friction. This pulls energy out of systems over time,
and makes those systems more stable. In our simulation, we’ll ignore air
friction, but we’ll add friction in the joints between bodies in order to have
better numerical and dynamic stability:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Joint</span><span class="o">*</span> <span class="n">joint</span> <span class="o">=</span> <span class="n">bn</span><span class="o">-&gt;</span><span class="n">getParentJoint</span><span class="p">();</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">joint</span><span class="o">-&gt;</span><span class="n">getNumDofs</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">joint</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setDampingCoefficient</span><span class="p">(</span><span class="n">default_damping_coefficient</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>If this BodyNode has a parent BodyNode, then we set damping coefficients of its
Joint to a default value.</p>

<h2 id="lesson-2-creating-a-soft-body">Lesson 2: Creating a soft body</h2>

<p>Find the templated function named <code class="highlighter-rouge">addSoftBody</code>. This function will have a
role identical to the <code class="highlighter-rouge">addRigidBody</code> function from earlier.</p>

<h3 id="lesson-2a-set-the-joint-properties">Lesson 2a: Set the Joint properties</h3>

<p>This portion is exactly the same as Lesson 1a. You can even copy the code
directly from there if you’d like to.</p>

<h3 id="lesson-2b-set-the-properties-of-the-soft-body">Lesson 2b: Set the properties of the soft body</h3>

<p>Last time we set the BodyNode properties after creating it, but this time
we’ll set them beforehand.</p>

<p>First, let’s create a struct for the properties that are unique to SoftBodyNodes:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SoftBodyNode</span><span class="o">::</span><span class="n">UniqueProperties</span> <span class="n">soft_properties</span><span class="p">;</span>
</code></pre>
</div>

<p>Later we will combine this with a standard <code class="highlighter-rouge">BodyNode::Properties</code> struct, but
for now let’s fill it in. Up above we defined an enumeration for a couple
different SoftBodyNode types. There is no official DART-native enumeration
for this, we created our own to use for this function. We’ll want to fill in
the <code class="highlighter-rouge">SoftBodyNode::UniqueProperties</code> struct based off of this enumeration:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">SOFT_BOX</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: make a soft box
</span><span class="p">}</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">SOFT_CYLINDER</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: make a soft cylinder
</span><span class="p">}</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">SOFT_ELLIPSOID</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// TODO: make a soft ellipsoid
</span><span class="p">}</span>
</code></pre>
</div>

<p>Each of these types has a static function in the <code class="highlighter-rouge">SoftBodyNodeHelper</code> class
that will set up your <code class="highlighter-rouge">UniqueProperties</code> for you. The arguments for each of
the functions are a bit complicated, so here is how to call it for each type:</p>

<p>For the SOFT_BOX:
```cpp
// Make a wide and short box
double width = default_shape_height, height = 2*default_shape_width;
Eigen::Vector3d dims(width, width, height);</p>

<p>Eigen::Vector3d dims(width, width, height);
double mass = 2<em>dims[0]</em>dims[1] + 2<em>dims[0]</em>dims[2] + 2<em>dims[1]</em>dims[2];
mass *= default_shape_density * default_skin_thickness;
soft_properties = SoftBodyNodeHelper::makeBoxProperties(
      dims, Eigen::Isometry3d::Identity(), Eigen::Vector3i(4,4,4), mass);
```</p>

<p>For the SOFT_CYLINDER:
```cpp
// Make a wide and short cylinder
double radius = default_shape_height/2.0, height = 2*default_shape_width;</p>

<p>// Mass of center
double mass = default_shape_density * height * 2<em>M_PI</em>radius
              * default_skin_thickness;
// Mass of top and bottom
mass += 2 * default_shape_density * M_PI*pow(radius,2)
            * default_skin_thickness;
soft_properties = SoftBodyNodeHelper::makeCylinderProperties(
      radius, height, 8, 3, 2, mass);
```</p>

<p>And for the SOFT_ELLIPSOID:
<code class="highlighter-rouge">cpp
double radius = default_shape_height/2.0;
Eigen::Vector3d dims = 2*radius*Eigen::Vector3d::Ones();
double mass = default_shape_density * 4.0*M_PI*pow(radius, 2)
              * default_skin_thickness;
soft_properties = SoftBodyNodeHelper::makeEllipsoidProperties(
      dims, 6, 6, mass);
</code></p>

<p>Feel free to play around with the different parameters, like number of slices
and number of stacks. However, be aware that some of those parameters have a
minimum value, usually of 2 or 3. During runtime, you should be warned if you
try to create one with a parameter that’s too small.</p>

<p>Lastly, we’ll want to fill in the softness coefficients:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">soft_properties</span><span class="p">.</span><span class="n">mKv</span> <span class="o">=</span> <span class="n">default_vertex_stiffness</span><span class="p">;</span>
<span class="n">soft_properties</span><span class="p">.</span><span class="n">mKe</span> <span class="o">=</span> <span class="n">default_edge_stiffness</span><span class="p">;</span>
<span class="n">soft_properties</span><span class="p">.</span><span class="n">mDampCoeff</span> <span class="o">=</span> <span class="n">default_soft_damping</span><span class="p">;</span>
</code></pre>
</div>

<h3 id="lesson-2c-create-the-joint-and-soft-body-pair">Lesson 2c: Create the Joint and Soft Body pair</h3>

<p>This step is very similar to Lesson 1b, except now we’ll want to specify
that we’re creating a soft BodyNode. First, let’s create a full 
<code class="highlighter-rouge">SoftBodyNode::Properties</code>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SoftBodyNode</span><span class="o">::</span><span class="n">Properties</span> <span class="n">body_properties</span><span class="p">(</span><span class="n">BodyNode</span><span class="o">::</span><span class="n">Properties</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
                                         <span class="n">soft_properties</span><span class="p">);</span>
</code></pre>
</div>

<p>This will combine the <code class="highlighter-rouge">UniqueProperties</code> of the SoftBodyNode with the
standard properties of a BodyNode. Now we can pass the whole thing into
the creation function:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SoftBodyNode</span><span class="o">*</span> <span class="n">bn</span> <span class="o">=</span> <span class="n">chain</span><span class="o">-&gt;</span><span class="n">createJointAndBodyNodePair</span><span class="o">&lt;</span><span class="n">JointType</span><span class="p">,</span> <span class="n">SoftBodyNode</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">parent</span><span class="p">,</span> <span class="n">joint_properties</span><span class="p">,</span> <span class="n">body_properties</span><span class="p">).</span><span class="n">second</span><span class="p">;</span>
</code></pre>
</div>

<p>Notice that this time it will return a <code class="highlighter-rouge">SoftBodyNode</code> pointer rather than a
normal <code class="highlighter-rouge">BodyNode</code> pointer. This is one of the advantages of templates!</p>

<h3 id="lesson-2d-zero-out-the-bodynode-inertia">Lesson 2d: Zero out the BodyNode inertia</h3>

<p>A SoftBodyNode has two sources of inertia: the underlying inertia of the
standard BodyNode class, and the point mass inertias of its soft skin. In our
case, we only want the point mass inertias, so we should zero out the standard
BodyNode inertia. However, zeroing out inertia values can be very dangerous,
because it can easily result in singularities. So instead of completely zeroing
them out, we will just make them small enough that they don’t impact the
simulation:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Inertia</span> <span class="n">inertia</span><span class="p">;</span>
<span class="n">inertia</span><span class="p">.</span><span class="n">setMoment</span><span class="p">(</span><span class="mf">1e-8</span><span class="o">*</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="o">::</span><span class="n">Identity</span><span class="p">());</span>
<span class="n">inertia</span><span class="p">.</span><span class="n">setMass</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">);</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">setInertia</span><span class="p">(</span><span class="n">inertia</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="lesson-2e-make-the-shape-transparent">Lesson 2e: Make the shape transparent</h3>

<p>To help us visually distinguish between the soft and rigid portions of a body,
we can make the soft part of the shape transparent. Upon creation, a SoftBodyNode
will have exactly one visualization shape: the soft shape visualizer. We can
grab that shape and reduce the value of its alpha channel:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Eigen::Vector4d color = bn-&gt;getVisualizationShape(0)-&gt;getRGBA();
color[3] = 0.4;
bn-&gt;getVisualizationShape(0)-&gt;setRGBA(color);
</code></pre>
</div>

<h3 id="lesson-2f-give-a-hard-bone-to-the-softbodynode">Lesson 2f: Give a hard bone to the SoftBodyNode</h3>

<p>SoftBodyNodes are intended to be used as soft skins that are attached to rigid
bones. We can create a rigid shape, place it in the SoftBodyNode, and give some
inertia to the SoftBodyNode’s base BodyNode class, to act as the inertia of the
bone.</p>

<p>Find the function <code class="highlighter-rouge">createSoftBody()</code>. Underneath the call to <code class="highlighter-rouge">addSoftBody</code>,
we can create a box shape that matches the dimensions of the soft box, but scaled
down:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">double</span> <span class="n">width</span> <span class="o">=</span> <span class="n">default_shape_height</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">default_shape_width</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">dims</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
<span class="n">dims</span> <span class="o">*=</span> <span class="mf">0.6</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">BoxShape</span><span class="o">&gt;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoxShape</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dims</span><span class="p">);</span>
</code></pre>
</div>

<p>And then we can add that shape to the visualization and collision shapes of the
SoftBodyNode, just like normal:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">bn</span><span class="o">-&gt;</span><span class="n">addCollisionShape</span><span class="p">(</span><span class="n">box</span><span class="p">);</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">addVisualizationShape</span><span class="p">(</span><span class="n">box</span><span class="p">);</span>
</code></pre>
</div>

<p>And we’ll want to make sure that we set the inertia of the underlying BodyNode,
or else the behavior will not be realistic:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Inertia</span> <span class="n">inertia</span><span class="p">;</span>
<span class="n">inertia</span><span class="p">.</span><span class="n">setMass</span><span class="p">(</span><span class="n">default_shape_density</span> <span class="o">*</span> <span class="n">box</span><span class="o">-&gt;</span><span class="n">getVolume</span><span class="p">());</span>
<span class="n">inertia</span><span class="p">.</span><span class="n">setMoment</span><span class="p">(</span><span class="n">box</span><span class="o">-&gt;</span><span class="n">computeInertia</span><span class="p">(</span><span class="n">inertia</span><span class="p">.</span><span class="n">getMass</span><span class="p">()));</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">setInertia</span><span class="p">(</span><span class="n">inertia</span><span class="p">);</span>
</code></pre>
</div>

<p>Note that the inertia of the inherited BodyNode is independent of the inertia
of the SoftBodyNode’s skin.</p>

<h3 id="lesson-2g-add-a-rigid-body-attached-by-a-weldjoint">Lesson 2g: Add a rigid body attached by a WeldJoint</h3>

<p>To make a more interesting hybrid shape, we can attach a protruding rigid body
to a SoftBodyNode using a WeldJoint. Find the <code class="highlighter-rouge">createHybridBody()</code> function
and see where we call the <code class="highlighter-rouge">addSoftBody</code> function. Just below this, we’ll
create a new rigid body with a WeldJoint attachment:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">bn</span> <span class="o">=</span> <span class="n">hybrid</span><span class="o">-&gt;</span><span class="n">createJointAndBodyNodePair</span><span class="o">&lt;</span><span class="n">WeldJoint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bn</span><span class="p">).</span><span class="n">second</span><span class="p">;</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="s">"rigid box"</span><span class="p">);</span>
</code></pre>
</div>

<p>Now we can give the new rigid BodyNode a regular box shape:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">double</span> <span class="n">box_shape_height</span> <span class="o">=</span> <span class="n">default_shape_height</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">BoxShape</span><span class="o">&gt;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoxShape</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">box_shape_height</span><span class="o">*</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">Ones</span><span class="p">());</span>

<span class="n">bn</span><span class="o">-&gt;</span><span class="n">addCollisionShape</span><span class="p">(</span><span class="n">box</span><span class="p">);</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">addVisualizationShape</span><span class="p">(</span><span class="n">box</span><span class="p">);</span>
</code></pre>
</div>

<p>To make the box protrude, we’ll shift it away from the center of its parent:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span> <span class="n">tf</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span><span class="o">::</span><span class="n">Identity</span><span class="p">());</span>
<span class="n">tf</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="n">box_shape_height</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">getParentJoint</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setTransformFromParentBodyNode</span><span class="p">(</span><span class="n">tf</span><span class="p">);</span>
</code></pre>
</div>

<p>And be sure to set its inertia, or else the simulation will not be realistic:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Inertia</span> <span class="n">inertia</span><span class="p">;</span>
<span class="n">inertia</span><span class="p">.</span><span class="n">setMass</span><span class="p">(</span><span class="n">default_shape_density</span> <span class="o">*</span> <span class="n">box</span><span class="o">-&gt;</span><span class="n">getVolume</span><span class="p">());</span>
<span class="n">inertia</span><span class="p">.</span><span class="n">setMoment</span><span class="p">(</span><span class="n">box</span><span class="o">-&gt;</span><span class="n">computeInertia</span><span class="p">(</span><span class="n">inertia</span><span class="p">.</span><span class="n">getMass</span><span class="p">()));</span>
<span class="n">bn</span><span class="o">-&gt;</span><span class="n">setInertia</span><span class="p">(</span><span class="n">inertia</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="lesson-3-setting-initial-conditions-and-taking-advantage-of-frames">Lesson 3: Setting initial conditions and taking advantage of Frames</h2>

<p>Find the <code class="highlighter-rouge">addObject</code> function in the <code class="highlighter-rouge">MyWorld</code> class. This function will
be called whenever the user requests for an object to be added to the world.
In this function, we want to set up the initial conditions for the object so
that it gets thrown at the wall. We also want to make sure that it’s not in
collision with anything at the time that it’s added, because that would result
in problems for the simulation.</p>

<h3 id="lesson-3a-set-the-starting-position-for-the-object">Lesson 3a: Set the starting position for the object</h3>

<p>We want to position the object in a reasonable place for us to throw it at the
wall. We also want to have the ability to randomize its location along the y-axis.</p>

<p>First, let’s create a zero vector for the position:
<code class="highlighter-rouge">cpp
Eigen::Vector6d positions(Eigen::Vector6d::Zero());
</code></p>

<p>You’ll notice that this is an Eigen::Vector<strong>6</strong>d rather than the usual
Eigen::Vector<strong>3</strong>d. This vector has six components because the root BodyNode
has 6 degrees of freedom: three for orientation and three for translation.
Because we follow Roy Featherstone’s Spatial Vector convention, the <strong>first</strong>
three components are for <strong>orientation</strong> using a logmap (also known as angle-axis)
and the <strong>last</strong> three components are for <strong>translation</strong>.</p>

<p>First, if randomness is turned on, we’ll set the y-translation to a randomized
value:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">mRandomize</span><span class="p">)</span>
  <span class="n">positions</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_spawn_range</span> <span class="o">*</span> <span class="n">mDistribution</span><span class="p">(</span><span class="n">mMT</span><span class="p">);</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">mDistribution(mMT)</code> will generate a random value in the range [-1, 1] 
inclusive because of how we initialized the classes in the constructor of
<code class="highlighter-rouge">MyWindow</code>.</p>

<p>Then we always set the height to the default value:
<code class="highlighter-rouge">cpp
positions[5] = default_start_height;
</code></p>

<p>Finally, we use this vector to set the positions of the root Joint:
<code class="highlighter-rouge">cpp
object-&gt;getJoint(0)-&gt;setPositions(positions);
</code></p>

<p>We trust that the root Joint is a FreeJoint with 6 degrees of freedom because
of how we constructed all the objects that are going to be thrown at the wall:
They were all given a FreeJoint between the world and the root BodyNode.</p>

<h3 id="lesson-3b-add-the-object-to-the-world">Lesson 3b: Add the object to the world</h3>

<p>Every object in the world is required to have a non-empty unique name. Just like
Joint names in a Skeleton, if we pass a Skeleton into a world with a non-unique
name, the world will print out a complaint to us and then rename it. So avoid the
ugly printout, we’ll make sure the new object has a unique name ahead of time:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">object</span><span class="o">-&gt;</span><span class="n">setName</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span><span class="o">+</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">mSkelCount</span><span class="o">++</span><span class="p">));</span>
</code></pre>
</div>

<p>And now we can add it to the world without any complaints:
<code class="highlighter-rouge">cpp
mWorld-&gt;addSkeleton(object);
</code></p>

<h3 id="lesson-3c-compute-collisions">Lesson 3c: Compute collisions</h3>

<p>Now that we’ve added the Skeleton to the world, we want to make sure that it
wasn’t actually placed inside of something accidentally. If an object in a 
simulation starts off inside of another object, it can result in extremely
non-physical simulations, perhaps even breaking the simulation entirely.
We can access the world’s collision detector directly to check make sure the
new object is collision-free:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">dart</span><span class="o">::</span><span class="n">collision</span><span class="o">::</span><span class="n">CollisionDetector</span><span class="o">*</span> <span class="n">detector</span> <span class="o">=</span>
    <span class="n">mWorld</span><span class="o">-&gt;</span><span class="n">getConstraintSolver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getCollisionDetector</span><span class="p">();</span>
<span class="n">detector</span><span class="o">-&gt;</span><span class="n">detectCollision</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</code></pre>
</div>

<p>Now we shouldn’t be surprised if the <em>other</em> objects are in collision with each
other, so we’ll want to look through the list of collisions and check whether
any of them are the new Skeleton:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">collision</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">collisionCount</span> <span class="o">=</span> <span class="n">detector</span><span class="o">-&gt;</span><span class="n">getNumContacts</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">collisionCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="n">dart</span><span class="o">::</span><span class="n">collision</span><span class="o">::</span><span class="n">Contact</span><span class="o">&amp;</span> <span class="n">contact</span> <span class="o">=</span> <span class="n">detector</span><span class="o">-&gt;</span><span class="n">getContact</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">contact</span><span class="p">.</span><span class="n">bodyNode1</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSkeleton</span><span class="p">()</span> <span class="o">==</span> <span class="n">object</span>
     <span class="o">||</span> <span class="n">contact</span><span class="p">.</span><span class="n">bodyNode2</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSkeleton</span><span class="p">()</span> <span class="o">==</span> <span class="n">object</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">collision</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>If the new Skeleton <em>was</em> in collision with anything, we’ll want to remove it
from the world and abandon our attempt to add it:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">collision</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mWorld</span><span class="o">-&gt;</span><span class="n">removeSkeleton</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The new object spawned in a collision. "</span>
            <span class="o">&lt;&lt;</span> <span class="s">"It will not be added to the world."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Of course we should also print out a message so that user understands why we
didn’t throw a new object.</p>

<h3 id="lesson-3d-creating-reference-frames">Lesson 3d: Creating reference frames</h3>

<p>DART has a unique feature that we call Frame Semantics. The Frame Semantics of
DART allow you to create reference frames and use them to get and set data
relative to arbitrary frames. There are two crucial Frame types currently used
in DART: <code class="highlighter-rouge">BodyNode</code>s and <code class="highlighter-rouge">SimpleFrame</code>s.</p>

<p>The BodyNode class does not allow you to explicitly set its transform, velocity,
or acceleration properties, because those are all strictly functions of the
degrees of freedom that the BodyNode depends on. Because of this, the BodyNode
is not a very convenient class if you want to create an arbitrary frame of
reference. Instead, DART offers the <code class="highlighter-rouge">SimpleFrame</code> class which gives you the
freedom of arbitarily attaching it to any parent Frame and setting its transform,
velocity, and acceleration to whatever you’d like. This makes SimpleFrame useful
for specifying arbitrary reference frames.</p>

<p>We’re going to set up a couple SimpleFrames and use them to easily specify the
velocity properties that we want the Skeleton to have. First, we’ll place a
SimpleFrame at the Skeleton’s center of mass:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span> <span class="n">centerTf</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Isometry3d</span><span class="o">::</span><span class="n">Identity</span><span class="p">());</span>
<span class="n">centerTf</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">getCOM</span><span class="p">();</span>
<span class="n">SimpleFrame</span> <span class="n">center</span><span class="p">(</span><span class="n">Frame</span><span class="o">::</span><span class="n">World</span><span class="p">(),</span> <span class="s">"center"</span><span class="p">,</span> <span class="n">centerTf</span><span class="p">);</span>
</code></pre>
</div>

<p>Calling <code class="highlighter-rouge">object-&gt;getCOM()</code> will tell us the center of mass location with
respect to the World Frame. We use that to set the translation of the
SimpleFrame’s relative transform so that the origin of the SimpleFrame will be
located at the object’s center of mass.</p>

<p>Now we’ll set what we want the object’s angular and linear speeds to be:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">double</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">default_launch_angle</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">default_start_v</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">angular_speed</span> <span class="o">=</span> <span class="n">default_start_w</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">mRandomize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">mDistribution</span><span class="p">(</span><span class="n">mMT</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">*</span>
      <span class="p">(</span><span class="n">maximum_launch_angle</span> <span class="o">-</span> <span class="n">minimum_launch_angle</span><span class="p">)</span> <span class="o">+</span> <span class="n">minimum_launch_angle</span><span class="p">;</span>

  <span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">mDistribution</span><span class="p">(</span><span class="n">mMT</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">*</span>
      <span class="p">(</span><span class="n">maximum_start_v</span> <span class="o">-</span> <span class="n">minimum_start_v</span><span class="p">)</span> <span class="o">+</span> <span class="n">minimum_start_v</span><span class="p">;</span>

  <span class="n">angular_speed</span> <span class="o">=</span> <span class="n">mDistribution</span><span class="p">(</span><span class="n">mMT</span><span class="p">)</span> <span class="o">*</span> <span class="n">maximum_start_w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We just use the default values unless randomization is turned on.</p>

<p>Now we’ll convert those speeds into directional velocities:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">v</span> <span class="o">=</span> <span class="n">speed</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">));</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">w</span> <span class="o">=</span> <span class="n">angular_speed</span> <span class="o">*</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">UnitY</span><span class="p">();</span>
</code></pre>
</div>

<p>And now we’ll use those vectors to set the velocity properties of the SimpleFrame:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">center</span><span class="p">.</span><span class="n">setClassicDerivatives</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">SimpleFrame::setClassicDerivatives()</code> allows you to set the classic linear
and angular velocities and accelerations of a SimpleFrame with respect to its
parent Frame, which in this case is the World Frame. In DART, classic velocity and
acceleration vectors are explicitly differentiated from spatial velocity and
acceleration vectors. If you are unfamiliar with the term “spatial vector”, then
you’ll most likely want to work in terms of classic velocity and acceleration.</p>

<p>Now we want to create a new SimpleFrame that will be a child of the previous one:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SimpleFrame</span> <span class="n">ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">center</span><span class="p">,</span> <span class="s">"root_reference"</span><span class="p">);</span>
</code></pre>
</div>

<p>And we want the origin of this new Frame to line up with the root BodyNode of
our object:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">ref</span><span class="p">.</span><span class="n">setRelativeTransform</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getTransform</span><span class="p">(</span><span class="o">&amp;</span><span class="n">center</span><span class="p">));</span>
</code></pre>
</div>

<p>Now we’ll use this reference frame to set the velocity of the root BodyNode.
By setting the velocity of the root BodyNode equal to the velocity of this
reference frame, we will ensure that the overall velocity of Skeleton’s center
of mass is equal to the velocity of the <code class="highlighter-rouge">center</code> Frame from earlier.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">object</span><span class="o">-&gt;</span><span class="n">getJoint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setVelocities</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">getSpatialVelocity</span><span class="p">());</span>
</code></pre>
</div>

<p>Note that the FreeJoint uses spatial velocity and spatial acceleration for its
degrees of freedom.</p>

<p>Now we’re ready to toss around objects!</p>

<h2 id="lesson-4-setting-joint-spring-and-damping-properties">Lesson 4: Setting joint spring and damping properties</h2>

<p>Find the <code class="highlighter-rouge">setupRing</code> function. This is where we’ll setup a chain of BodyNodes
so that it behaves more like a closed ring.</p>

<h3 id="lesson-4a-set-the-spring-and-damping-coefficients">Lesson 4a: Set the spring and damping coefficients</h3>

<p>We’ll want to set the stiffness and damping coefficients of only the
DegreesOfFreedom that are <strong>between</strong> two consecutive BodyNodes. The first
six degrees of freedom are between the root BodyNode and the World, so we don’t
want to change the stiffness of them, or else the object will hover unnaturally
in the air. But all the rest of the degrees of freedom should be set:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getNumDofs</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">DegreeOfFreedom</span><span class="o">*</span> <span class="n">dof</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">dof</span><span class="o">-&gt;</span><span class="n">setSpringStiffness</span><span class="p">(</span><span class="n">ring_spring_stiffness</span><span class="p">);</span>
  <span class="n">dof</span><span class="o">-&gt;</span><span class="n">setDampingCoefficient</span><span class="p">(</span><span class="n">ring_damping_coefficient</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="lesson-4b-set-the-rest-positions-of-the-joints">Lesson 4b: Set the rest positions of the joints</h3>

<p>We want to make sure that the ring’s rest position works well for the structure
it has. Using basic geometry, we know we can compute the exterior angle on each
edge of a polygon like so:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">numEdges</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getNumBodyNodes</span><span class="p">();</span>
<span class="kt">double</span> <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">M_PI</span><span class="o">/</span><span class="n">numEdges</span><span class="p">;</span>
</code></pre>
</div>

<p>Now it’s important to remember that the joints we have between the BodyNodes are
BallJoints, which use logmaps (a.k.a. angle-axis) to represent their positions.
The BallJoint class provides a convenience function for converting rotations
into a position vector for a BallJoint. A similar function also exists for
EulerJoint and FreeJoint.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getNumJoints</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Joint</span><span class="o">*</span> <span class="n">joint</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getJoint</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxisd</span> <span class="n">rotation</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">restPos</span> <span class="o">=</span> <span class="n">BallJoint</span><span class="o">::</span><span class="n">convertToPositions</span><span class="p">(</span>
        <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="p">(</span><span class="n">rotation</span><span class="p">));</span>

  <span class="c1">// TODO: Set the rest position
</span><span class="p">}</span>
</code></pre>
</div>

<p>Now we can set the rest positions component-wise:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code>  <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="n">joint</span><span class="o">-&gt;</span><span class="n">setRestPosition</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">restPos</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</code></pre>
</div>

<h3 id="lesson-4c-set-the-joints-to-be-in-their-rest-positions">Lesson 4c: Set the Joints to be in their rest positions</h3>

<p>Finally, we should set the ring so that all the degrees of freedom (past the
root BodyNode) start out in their rest positions:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getNumDofs</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">DegreeOfFreedom</span><span class="o">*</span> <span class="n">dof</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">dof</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">getRestPosition</span><span class="p">());</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="lesson-5-create-a-closed-kinematic-chain">Lesson 5: Create a closed kinematic chain</h2>

<p>Find the <code class="highlighter-rouge">addRing</code> function in <code class="highlighter-rouge">MyWindow</code>. In here, we’ll want to create a
dynamic constraint that attaches the first and last BodyNodes of the chain
together by a BallJoint-style constraint.</p>

<p>First we’ll grab the BodyNodes that we care about:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">BodyNode</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">BodyNode</span><span class="o">*</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">getNumBodyNodes</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>Now we want to compute the offset where the BallJoint constraint should be located:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">default_shape_height</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="n">offset</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">getWorldTransform</span><span class="p">()</span> <span class="o">*</span> <span class="n">offset</span><span class="p">;</span>
</code></pre>
</div>

<p>The offset will be located half the default height up from the center of the
tail BodyNode.</p>

<p>Now we have everything we need to construct the constraint:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">dart</span><span class="o">::</span><span class="n">constraint</span><span class="o">::</span><span class="n">BallJointConstraint</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</code></pre>
</div>

<p>In order for the constraint to work, we’ll need to add it to the world’s
constraint solver:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mWorld</span><span class="o">-&gt;</span><span class="n">getConstraintSolver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">);</span>
</code></pre>
</div>

<p>And in order to properly clean up the constraint when removing BodyNodes, we’ll
want to add it to our list of constraints:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">mJointConstraints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">constraint</span><span class="p">);</span>
</code></pre>
</div>

<p>And that’s it! You’re ready to run the full tutorialCollisions application!</p>

<p><strong>When running the application, keep in mind that the dynamics of collisions are
finnicky, so you may see some unstable and even completely non-physical behavior.
If the application freezes, you may need to force quit out of it.</strong></p>

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="http://dart.readthedocs.org/en/release-5.1/tutorials/collisions/" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true"></div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'dartsim';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



    <div class="tags">
        
    </div>

    

</div>

<hr class="shaded"/>

<footer>
            <div class="row">
                <div class="col-lg-12 footer">
               &copy;2016 Georgia Tech and Carnegie Mellon University. All rights reserved. <br />
 Site last generated: Oct 6, 2016 <br />
<p><img src="images/dart_logo_big.jpg" alt="DART logo" style="width:128px"/></p>
                </div>
            </div>
</footer>


    </div>
    <!-- /.row -->
</div>
<!-- /.container -->
    </div>

</body>

</html>