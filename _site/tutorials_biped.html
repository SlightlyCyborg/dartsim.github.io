<!DOCTYPE html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="keywords" content=" sample">
<title>Biped | DART Website</title>
<link rel="stylesheet" href="css/syntax.css">


<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
<!--<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">-->
<link rel="stylesheet" href="css/modern-business.css">
<link rel="stylesheet" href="css/lavish-bootstrap.css">
<link rel="stylesheet" href="css/customstyles.css">
<link rel="stylesheet" href="css/theme-blue.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="js/jquery.navgoco.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/2.0.0/anchor.min.js"></script>
<script src="js/toc.js"></script>
<script src="js/customscripts.js"></script>

<link rel="shortcut icon" href="images/favicon.ico">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link rel="alternate" type="application/rss+xml" title="" href="http://idratherbewriting.comfeed.xml">

    <script>
        $(document).ready(function() {
            // Initialize navgoco with default options
            $("#mysidebar").navgoco({
                caretHtml: '',
                accordion: true,
                openClass: 'active', // open
                save: false, // leave false or nav highlighting doesn't work right
                cookie: {
                    name: 'navgoco',
                    expires: false,
                    path: '/'
                },
                slide: {
                    duration: 400,
                    easing: 'swing'
                }
            });

            $("#collapseAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', false);
            });

            $("#expandAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', true);
            });

        });

    </script>
    <script>
        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        })
    </script>
    

</head>
<body>
<!-- Navigation -->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="fa fa-home fa-lg navbar-brand" href="index.html">&nbsp;<span class="projectTitle"> DART</span></a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- entries without drop-downs appear here -->
                
                
                
                <li><a href="tutorials_introduction.html">Tutorials</a></li>
                
                
                
                <!-- entries with drop-downs appear here -->
                <!-- conditional logic to control which topnav appears for the audience defined in the configuration file.-->
                
                
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Github<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        
                        
                        <li><a href="http://github.com/dartsim/dart" target="_blank">View Project on Github</a></li>
                        
                        
                        
                        <li><a href="https://github.com/dartsim/dart/issues" target="_blank">Report Issue</a></li>
                        
                        
                    </ul>
                </li>
                
                
                
			<li><a class="email" title="Submit feedback" href="#" onclick="javascript:window.location='mailto:jslee02@gmail.com?subject=DART feedback f eedback&body=I have some feedback about the Biped page: ' + window.location.href;"><i class="fa fa-envelope-o"></i> Feedback</a><li>

		
                <!--comment out this block if you want to hide search-->
                <li>
                    <!--start search-->
                    <div id="search-demo-container">
                        <input type="text" id="search-input" placeholder="search...">
                        <ul id="results-container"></ul>
                    </div>
                    <script src="js/jekyll-search.js" type="text/javascript"></script>
                    <script type="text/javascript">
                            SimpleJekyllSearch.init({
                                searchInput: document.getElementById('search-input'),
                                resultsContainer: document.getElementById('results-container'),
                                dataSource: 'search.json',
                                searchResultTemplate: '<li><a href="{url}" title="Biped">{title}</a></li>',
                    noResultsText: 'No results found.',
                            limit: 10,
                            fuzzy: true,
                    })
                    </script>
                    <!--end search-->
                </li>
            </ul>
        </div>
        </div>
        <!-- /.container -->
</nav>

<!-- Page Content -->
<div class="container">
    <div class="col-lg-12">&nbsp;</div>
    <!-- Content Row -->
    <div class="row">
        <!-- Sidebar Column -->
        <div class="col-md-3">

          












<ul id="mysidebar" class="nav">
    <li class="sidebarTitle">DART Tutorials 6.1.0</li>
    
    
    
        
    
    <li>
        <a href="#">Tutorials</a>
        <ul>
            
            
            
            <li><a href="tutorials_introduction.html">Introduction</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_pendulum.html">Pendulum</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_collisions.html">Collisions</a></li>
            
            
            
            
            
            
            <li><a href="tutorials_manipulator.html">Manipulator</a></li>
            
            
            
            
            
            
            <li class="active"><a href="tutorials_biped.html">Biped</a></li>
            
            
            
            
        </ul>
        
        
        
        <!-- if you aren't using the accordion, uncomment this block:
           <p class="external">
               <a href="#" id="collapseAll">Collapse All</a> | <a href="#" id="expandAll">Expand All</a>
           </p>
           -->
    </li>
</ul>
</div>

<!-- this highlights the active parent class in the navgoco sidebar. this is critical so that the parent expands when you're viewing a page. This must appear below the sidebar code above. Otherwise, if placed inside customscripts.js, the script runs before the sidebar code runs and the class never gets inserted.-->
<script>$("li.active").parents('li').toggleClass("active");</script>

    <!-- Content Column -->
    <div class="col-md-9">
        <div class="post-header">
   <h1 class="post-title-main">Biped</h1>
</div>



<div class="post-content">

   

    
    
<!-- this handles the automatic toc. use ## for subheads to auto-generate the on-page minitoc. if you use html tags, you must supply an ID for the heading element in order for it to appear in the minitoc. -->
<script>
$( document ).ready(function() {
  // Handler for .ready() called.

$('#toc').toc({ minimumHeaders: 0, listType: 'ul', showSpeed: 0, headers: 'h2,h3,h4' });

/* this offset helps account for the space taken up by the floating toolbar. */
$('#toc').on('click', 'a', function() {
  var target = $(this.getAttribute('href'))
    , scroll_target = target.offset().top

  $(window).scrollTop(scroll_target - 10);
  return false
})
  
});
</script>

<div id="toc"></div>

    

    

    

    <a target="_blank" href="https://github.com/tomjohnson1492/documentation-theme-jekyll/blob/gh-pages/pages//_pages/tutorials/tutorials_biped.html.md" class="btn btn-default githubEditButton" role="button"><i class="fa fa-github fa-lg"></i> Edit me</a>
    

    

  <h2 id="overview">Overview</h2>
<p>This tutorial demonstrates the dynamic features in DART useful for
developing controllers for bipedal or wheel-based robots. The tutorial
consists of seven Lessons covering the following topics:</p>

<ul>
  <li>Joint limits and self-collision.</li>
  <li>Actuators types and management.</li>
  <li>APIs for Jacobian matrices and other kinematic quantities.</li>
  <li>APIs for dynamic quantities.</li>
  <li>Skeleton editing.</li>
</ul>

<p>Please reference the source code in <a href="https://github.com/dartsim/dart/blob/release-6.0/tutorials/tutorialBiped.cpp"><strong>tutorialBiped.cpp</strong></a> and <a href="https://github.com/dartsim/dart/blob/release-6.0/tutorials/tutorialBiped-Finished.cpp"><strong>tutorialBiped-Finished.cpp</strong></a>.</p>

<h2 id="lesson-1-joint-limits-and-self-collision">Lesson 1: Joint limits and self-collision</h2>
<p>Let’s start by locating the <code class="highlighter-rouge">main</code> function in tutorialBiped.cpp. We first create a floor
and call <code class="highlighter-rouge">loadBiped</code> to load a bipedal figure described in SKEL
format, which is an XML format representing a robot model. A SKEL file
describes a <code class="highlighter-rouge">World</code> with one or more <code class="highlighter-rouge">Skeleton</code>s in it. Here we
load in a World from <a href="https://github.com/dartsim/dart/blob/release-5.1/data/skel/biped.skel"><strong>biped.skel</strong></a> and assign the bipedal figure to a
<code class="highlighter-rouge">Skeleton</code> pointer called <em>biped</em>.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SkeletonPtr</span> <span class="nf">loadBiped</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">WorldPtr</span> <span class="n">world</span> <span class="o">=</span> <span class="n">SkelParser</span><span class="o">::</span><span class="n">readWorld</span><span class="p">(</span><span class="n">DART_DATA_PATH</span><span class="s">"skel/biped.skel"</span><span class="p">);</span>
    <span class="n">SkeletonPtr</span> <span class="n">biped</span> <span class="o">=</span> <span class="n">world</span><span class="o">-&gt;</span><span class="n">getSkeleton</span><span class="p">(</span><span class="s">"biped"</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Running the skeleton code (hit the spacebar) without any modification, you should see a
human-like character collapse on the ground and fold in on
itself. Before we attempt to control the biped, let’s first make the
biped a bit more realistic by enforcing more human-like joint limits.</p>

<p>DART allows the user to set upper and lower bounds on each degree of
freedom in the SKEL file or using provided APIs. For example, you
should see the description of the right knee joint in <strong>biped.skel</strong>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">joint</span> <span class="n">type</span><span class="o">=</span><span class="s">"revolute"</span> <span class="n">name</span><span class="o">=</span><span class="s">"j_shin_right"</span><span class="o">&gt;</span>
<span class="p">...</span>
    <span class="o">&lt;</span><span class="n">axis</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">xyz</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">1.0</span><span class="o">&lt;/</span><span class="n">xyz</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">limit</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="n">lower</span><span class="o">&gt;-</span><span class="mf">3.14</span><span class="o">&lt;/</span><span class="n">lower</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="n">upper</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="o">&lt;/</span><span class="n">upper</span><span class="o">&gt;</span>
        <span class="o">&lt;/</span><span class="n">limit</span><span class="o">&gt;</span>                  
    <span class="o">&lt;/</span><span class="n">axis</span><span class="o">&gt;</span>
<span class="p">...</span>
<span class="o">&lt;/</span><span class="n">joint</span><span class="o">&gt;</span>
</code></pre>
</div>
<p>The &lt;upper&gt; and &lt;lower&gt; tags make sure that the knee can only flex but
not extend. Alternatively, you can directly specify the joint limits
in the code using
<code class="highlighter-rouge">setPositionUpperLimit</code> and <code class="highlighter-rouge">setPositionLowerLimit</code>.</p>

<p>In either case, the joint limits on the biped will not be activated
until you call <code class="highlighter-rouge">setPositionLimited</code>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SkeletonPtr</span> <span class="nf">loadBiped</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">biped</span><span class="o">-&gt;</span><span class="n">getNumJoints</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">biped</span><span class="o">-&gt;</span><span class="n">getJoint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setPositionLimited</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Once the joint limits are set, the next task is to enforce
self-collision. By default, DART does not check self-collision within
a skeleton. You can enable self-collision checking on the biped by
<code class="highlighter-rouge">cpp
SkeletonPtr loadBiped()
{
...
    biped-&gt;enableSelfCollision();
...
}
</code>
This function will enable self-collision on every non-adjacent pair of
body nodes. If you wish to also enable self-collision on adjacent body
nodes, set the optional parameter to true:
<code class="highlighter-rouge">cpp
biped-&gt;enableSelfCollision(true);
</code>
Running the program again, you should see that the character is still
floppy like a ragdoll, but now the joints do not bend backward and the
body nodes do not penetrate each other anymore.</p>

<h2 id="lesson-2-proportional-derivative-control">Lesson 2: Proportional-derivative control</h2>

<p>To actively control its own motion, the biped must exert internal
forces using actuators. In this Lesson, we will design one of the
simplest controllers to produce internal forces that make the biped
hold a target pose. The proportional-derivative (PD) control computes
control force by Τ = -k<sub>p</sub> (θ -
θ<sub>target</sub>) - k<sub>d</sub> θ̇, where θ
and θ̇ are the current position and velocity of a degree of
freedom, θ<sub>target</sub> is the target position set by the
controller, and k<sub>p</sub> and k<sub>d</sub> are the stiffness and
damping coefficients. The detailed description of a PD controller can
be found <a href="https://en.wikipedia.org/wiki/PID_controller">here</a>.</p>

<p>The first task is to set the biped to a particular configuration. You
can use <code class="highlighter-rouge">setPosition</code> to set each degree of freedom individually:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setInitialPose</span><span class="p">(</span><span class="n">SkeletonPtr</span> <span class="n">biped</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">biped</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">biped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"j_thigh_left_z"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">(),</span> <span class="mf">0.15</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Here the degree of freedom named “j_thigh_left_z” is set to 0.15
radian. Note that each degree of freedom in a skeleton has a numerical
index which can be accessed by
<code class="highlighter-rouge">getIndexInSkeleton</code>. You
can also set the entire configuration using a vector that holds the
positions of all the degreed of freedoms using
<code class="highlighter-rouge">setPositions</code>.</p>

<p>We continue to set more degrees of freedoms in the lower
body to create a roughly stable standing pose.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">biped</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">biped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"j_thigh_left_z"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">(),</span> <span class="mf">0.15</span><span class="p">);</span>
<span class="n">biped</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">biped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"j_thigh_right_z"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">(),</span> <span class="mf">0.15</span><span class="p">);</span>
<span class="n">biped</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">biped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"j_shin_left"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">);</span>
<span class="n">biped</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">biped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"j_shin_right"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">);</span>
<span class="n">biped</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">biped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"j_heel_left_1"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">(),</span> <span class="mf">0.25</span><span class="p">);</span>
<span class="n">biped</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">biped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"j_heel_right_1"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">(),</span> <span class="mf">0.25</span><span class="p">);</span>
</code></pre>
</div>

<p>Now the biped will start in this configuration, but will not maintain
this configuration as soon as the simulation starts. We need a
controller to make this happen. Let’s take a look at the constructor of our <code class="highlighter-rouge">Controller</code> in the
skeleton code:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Controller</span><span class="p">(</span><span class="k">const</span> <span class="n">SkeletonPtr</span><span class="o">&amp;</span> <span class="n">biped</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mKp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        <span class="n">mKd</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getNumDofs</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mKp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="n">mKd</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">setTargetPositions</span><span class="p">(</span><span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getPositions</span><span class="p">());</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Here we arbitrarily define the stiffness and damping coefficients to
1000 and 50, except for the first six degrees of freedom. Because the
global translation and rotation of the biped are not actuated, the
first six degrees of freedom at the root do not exert any internal
force. Therefore, we set the stiffness and damping coefficients to
zero. At the end of the constructor, we set the target position of the PD
controller to the current configuration of the biped.</p>

<p>With these settings, we can compute the forces generated by the PD
controller and add them to the internal forces of biped using <code class="highlighter-rouge">setForces</code>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">addPDForces</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getPositions</span><span class="p">();</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getVelocities</span><span class="p">();</span>
    
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">mKp</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">mTargetPositions</span><span class="p">);</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">mKd</span> <span class="o">*</span> <span class="n">dq</span><span class="p">;</span>
    
    <span class="n">mForces</span> <span class="o">+=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">setForces</span><span class="p">(</span><span class="n">mForces</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Note that the PD control force is <em>added</em> to the current internal force
stored in mForces instead of overriding it.</p>

<p>Now try to run the program and see what happens. The skeleton
disappears almost immediately as soon as you hit the space bar! This
is because our stiffness and damping coefficients are set way too
high. As soon as the biped deviates from the target position, huge
internal forces are generated to cause the numerical simulation to
blow up.</p>

<p>So let’s lower those coefficients a bit. It turns out that each of the
degrees of freedom needs to be individually tuned depending on many
factors, such as the inertial properties of the body nodes, the type
and properties of joints, and the current configuration of the
system. Figuring out an appropriate set of coefficients can be a
tedious process difficult to generalize across new tasks or different
skeletons. In the next Lesson, we will introduce a much more efficient
way to stabilize the PD controllers without endless tuning and
trial-and-errors.</p>

<h2 id="lesson-3-stable-pd-control">Lesson 3: Stable PD control</h2>

<p>SPD is a variation of PD control proposed by
<a href="http://www.cc.gatech.edu/~jtan34/project/spd.html">Jie Tan</a>. The
basic idea of SPD is to compute control force using the predicted
state at the next time step, instead of the current state. This Lesson
will only demonstrate the implementation of SPD using DART without
going into details of SPD derivation.</p>

<p>The implementation of SPD involves accessing the current dynamic
quantities in Lagrange’s equations of motion. Fortunately, these
quantities are readily available via DART API, which makes the full
implementation of SPD simple and concise:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">addSPDForces</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getPositions</span><span class="p">();</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getVelocities</span><span class="p">();</span>

    <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">invM</span> <span class="o">=</span> <span class="p">(</span><span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getMassMatrix</span><span class="p">()</span> <span class="o">+</span> <span class="n">mKd</span> <span class="o">*</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getTimeStep</span><span class="p">()).</span><span class="n">inverse</span><span class="p">();</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">mKp</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span> <span class="o">+</span> <span class="n">dq</span> <span class="o">*</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getTimeStep</span><span class="p">()</span> <span class="o">-</span> <span class="n">mTargetPositions</span><span class="p">);</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">mKd</span> <span class="o">*</span> <span class="n">dq</span><span class="p">;</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">qddot</span> <span class="o">=</span> <span class="n">invM</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getCoriolisAndGravityForces</span><span class="p">()</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getConstraintForces</span><span class="p">());</span>

    <span class="n">mForces</span> <span class="o">+=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="n">mKd</span> <span class="o">*</span> <span class="n">qddot</span> <span class="o">*</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getTimeStep</span><span class="p">();</span>
    <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">setForces</span><span class="p">(</span><span class="n">mForces</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>You can get mass matrix, Coriolis force, gravitational force, and
constraint force projected onto generalized coordinates using function
calls <code class="highlighter-rouge">getMassMatrix</code>,
<code class="highlighter-rouge">getCoriolisForces</code>,
<code class="highlighter-rouge">getGravityForces</code>,
and
<code class="highlighter-rouge">getConstraintForces</code>,
respectively. Constraint forces include forces due to contacts, joint
limits, and other joint constraints set by the user (e.g. the weld
joint constraint in the multi-pendulum tutorial).</p>

<p>With SPD, a wide range of stiffness and damping coefficients will all
result in stable motion. In fact, you can just leave them to our
original values: 1000 and 50. By holding the target pose, now the biped
can stand on the ground in balance indefinitely. However, if you apply
an external push force on the biped (hit ‘,’ or ‘.’ key to apply a
backward or forward push), the biped loses its balance quickly. We
will demonstrate a more robust feedback controller in the next Lesson.</p>

<h2 id="lesson-4-ankle-strategy">Lesson 4: Ankle strategy</h2>

<p>Ankle (or hip) strategy is an effective way to maintain standing
balance. The idea is to adjust the target position of ankles according
to the deviation between the center of mass and the center of pressure
projected on the ground. A simple linear feedback rule is used to
update the target ankle position: θ<sub>a</sub> = -k<sub>p</sub>
(x - p) - k<sub>d</sub> (ẋ - ṗ), where x and p indicate the
center of mass and center of pressure in the anterior-posterior
axis. k<sub>p</sub> and k<sub>d</sub> are the feedback gains defined
by the user.</p>

<p>To implement ankle strategy, let’s first compute the deviation between
the center of mass and an approximated center of pressure in the
anterior-posterior axis:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">addAnkleStrategyForces</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">COM</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getCOM</span><span class="p">();</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">offset</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">COP</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="s">"h_heel_left"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getTransform</span><span class="p">()</span> <span class="o">*</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">COM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">COP</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>DART provides various APIs to access useful kinematic information. For
example, <code class="highlighter-rouge">getCOM</code> returns the center of mass of the skeleton and
<code class="highlighter-rouge">getTransform</code> returns transformation of the body node with
respect to any coordinate frame specified by the parameter (world
coordinate frame as default). DART APIs also come in handy when
computing the derivative term,  -k<sub>d</sub> (ẋ - ṗ):</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">addAnkleStrategyForces</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">dCOM</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getCOMLinearVelocity</span><span class="p">();</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">dCOP</span> <span class="o">=</span>  <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="s">"h_heel_left"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getLinearVelocity</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">dDiff</span> <span class="o">=</span> <span class="n">dCOM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dCOP</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The linear/angular velocity/acceleration of any point in any coordinate
frame can be easily accessed in DART. The full list of the APIs for accessing
various velocities/accelerations can be found in the <a href="http://dartsim.github.io/dart/">API Documentation</a>. The 
following table summarizes the essential APIs.</p>

<table>
  <thead>
    <tr>
      <th>Function Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>getSpatialVelocity</td>
      <td>Return the spatial velocity of this BodyNode in the coordinates of the BodyNode.</td>
    </tr>
    <tr>
      <td>getLinearVelocity</td>
      <td>Return the linear portion of classical velocity of the BodyNode relative to some other BodyNode.</td>
    </tr>
    <tr>
      <td>getAngularVelocity</td>
      <td>Return the angular portion of classical velocity of this BodyNode relative to some other BodyNode.</td>
    </tr>
    <tr>
      <td>getSpatialAcceleration</td>
      <td>Return the spatial acceleration of this BodyNode in the coordinates of the BodyNode.</td>
    </tr>
    <tr>
      <td>getLinearAcceleration</td>
      <td>Return the linear portion of classical acceleration of the BodyNode relative to some other BodyNode.</td>
    </tr>
    <tr>
      <td>getAngularAcceleration</td>
      <td>Return the angular portion of classical acceleration of this BodyNode relative to some other BodyNode.</td>
    </tr>
  </tbody>
</table>

<p>The remaining of the ankle strategy implementation is just the matter
of parameters tuning. We found that using different feedback rules for
falling forward and backward result in more stable controller.</p>

<h2 id="lesson-5-skeleton-editing">Lesson 5: Skeleton editing</h2>

<p>DART provides various functions to copy, delete, split, and merge
parts of skeletons to alleviate the pain of building simulation models from
scratch. In this Lesson, we will load a skateboard model from a SKEL
file and merge our biped with the skateboard to create a wheel-based
robot.</p>

<p>We first load a skateboard from <strong>skateboard.skel</strong>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">modifyBipedWithSkateboard</span><span class="p">(</span><span class="n">SkeletonPtr</span> <span class="n">biped</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">WorldPtr</span> <span class="n">world</span> <span class="o">=</span> <span class="n">SkelParser</span><span class="o">::</span><span class="n">readWorld</span><span class="p">(</span><span class="n">DART_DATA_PATH</span><span class="s">"skel/skateboard.skel"</span><span class="p">);</span>
    <span class="n">SkeletonPtr</span> <span class="n">skateboard</span> <span class="o">=</span> <span class="n">world</span><span class="o">-&gt;</span><span class="n">getSkeleton</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Our goal is to make the skateboard Skeleton a subtree of the biped
Skeleton connected to the left heel BodyNode via a newly created
Euler joint. To do so, you need to first create an instance of
<code class="highlighter-rouge">EulerJoint::Properties</code> for this new joint.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">modifyBipedWithSkateboard</span><span class="p">(</span><span class="n">SkeletonPtr</span> <span class="n">biped</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">EulerJoint</span><span class="o">::</span><span class="n">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">EulerJoint</span><span class="o">::</span><span class="n">Properties</span><span class="p">();</span>
    <span class="n">properties</span><span class="p">.</span><span class="n">mT_ChildBodyToJoint</span><span class="p">.</span><span class="n">translation</span><span class="p">()</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Here we increase the vertical distance between the child BodyNode and
the joint by 0.1m to give some space between the skateboard and the
left foot. Now you can merge the skateboard and the biped using this new Euler
joint by</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">modifyBipedWithSkateboard</span><span class="p">(</span><span class="n">SkeletonPtr</span> <span class="n">biped</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">skateboard</span><span class="o">-&gt;</span><span class="n">getRootBodyNode</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">moveTo</span><span class="o">&lt;</span><span class="n">EulerJoint</span><span class="o">&gt;</span><span class="p">(</span><span class="n">biped</span><span class="o">-&gt;</span><span class="n">getBodyNode</span><span class="p">(</span><span class="s">"h_heel_left"</span><span class="p">),</span> <span class="n">properties</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>There are many other functions you can use to edit skeletons. Here is
a table of some relevant functions for quick references.</p>

<table>
  <thead>
    <tr>
      <th>Function Name</th>
      <th>Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>remove</td>
      <td>bd1-&gt;remove()</td>
      <td>Remove the BodyNode bd1 and its subtree from their Skeleton.</td>
    </tr>
    <tr>
      <td>moveTo</td>
      <td>bd1-&gt;moveTo(bd2)</td>
      <td>Move the BodyNode bd1 and its subtree under the BodyNode bd2.</td>
    </tr>
    <tr>
      <td>split</td>
      <td>auto newSkel = bd1-&gt;split(“new skeleton”)`</td>
      <td>Remove the BodyNode bd1 and its subtree from their current Skeleton and move them into a newly created Skeleton with “new skeleton” name.</td>
    </tr>
    <tr>
      <td>changeParentJointType</td>
      <td>bd1-&gt;changeParentJointType&lt;BallJoint&gt;()</td>
      <td>Change the Joint type of the BodyNode bd1’s parent joint to BallJoint</td>
    </tr>
    <tr>
      <td>copyTo</td>
      <td>bd1-&gt;copyTo(bd2)</td>
      <td>Create clones of the BodyNode bd1 and its subtree and attach the clones to the specified the BodyNode bd2.</td>
    </tr>
    <tr>
      <td>copyAs</td>
      <td>auto newSkel = bd1-&gt;copyAs(“new skeleton”)</td>
      <td>Create clones of the BodyNode bd1 and its subtree and create a new Skeleton with “new skeleton” name to attach them to.</td>
    </tr>
  </tbody>
</table>

<h2 id="lesson-6-actuator-types">Lesson 6: Actuator types</h2>

<p>DART provides five types of actuator. Each joint can select its own
actuator type.</p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>FORCE</td>
      <td>Take joint force and return the resulting joint acceleration.</td>
    </tr>
    <tr>
      <td>PASSIVE</td>
      <td>Take nothing (joint force = 0) and return the resulting joint acceleration.</td>
    </tr>
    <tr>
      <td>ACCELERATION</td>
      <td>Take desired joint acceleration and return the joint force to achieve the acceleration.</td>
    </tr>
    <tr>
      <td>VELOCITY</td>
      <td>Take desired joint velocity and return the joint force to achieve the velocity.</td>
    </tr>
    <tr>
      <td>LOCKED</td>
      <td>Lock the joint by setting the joint velocity and acceleration to zero and return the joint force to lock the joint.</td>
    </tr>
  </tbody>
</table>

<p>In this Lesson, we will switch the actuator type of the wheels
from the default FORCE type to VELOCITY type.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setVelocityAccuators</span><span class="p">(</span><span class="n">SkeletonPtr</span> <span class="n">biped</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Joint</span><span class="o">*</span> <span class="n">wheel1</span> <span class="o">=</span> <span class="n">biped</span><span class="o">-&gt;</span><span class="n">getJoint</span><span class="p">(</span><span class="s">"joint_front_left"</span><span class="p">);</span>
    <span class="n">wheel1</span><span class="o">-&gt;</span><span class="n">setActuatorType</span><span class="p">(</span><span class="n">Joint</span><span class="o">::</span><span class="n">VELOCITY</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Once all four wheels are set to VELOCITY actuator type, you can
command them by directly setting the desired velocity:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setWheelCommands</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="kt">int</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"joint_front_left_2"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">();</span>
    <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">setCommand</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">mSpeed</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Note that <code class="highlighter-rouge">setCommand</code> only exerts commanding force in the current time step. If you wish the
wheel to continue spinning at a particular speed, <code class="highlighter-rouge">setCommand</code>
needs to be called at every time step.</p>

<p>We also set the stiffness and damping coefficients for the wheels to zero.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setWheelCommands</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">wheelFirstIndex</span> <span class="o">=</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getDof</span><span class="p">(</span><span class="s">"joint_front_left_1"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getIndexInSkeleton</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">wheelFirstIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mBiped</span><span class="o">-&gt;</span><span class="n">getNumDofs</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mKp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        <span class="n">mKd</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This is because we do not want the velocity-based actuators to
incorrectly affect the computation of SPD. If we use simple PD
control scheme, the values of these spring and damping coefficients do not
affect the dynamics of the system.</p>

<p>Let’s simulate what we’ve got so far. The biped now is connecting to the
skateboard through a Euler joint. Once the simulation starts, you can
use ‘a’ and ‘s’ to increase or decrease the wheel speed. However, the
biped falls on the floor immediately because the current target pose is not
balanced for one-foot stance. We need to find a better target
pose.</p>

<h2 id="lesson-7-inverse-kinematics">Lesson 7: Inverse kinematics</h2>

<p>Instead of manually designing a target pose, this time we will solve for
a balanced pose by formulating an inverse kinematics (IK) problem and
solving it using gradient descent method. In this example, a balanced
pose is defined as a pose where the center of mass is well supported
by the ground contact and the left foot lies flat on the ground. As
such, we cast IK as an optimization problem that minimizes the
horizontal deviation between the center of mass and the center of the
left foot, as well as the vertical distance of the four corners of the
left foot from the ground:</p>

<p><img src="IKObjective.png" width="180" /></p>

<p>where <b>c</b> and <b>p</b> indicate the projected center of mass and center of
pressure on the ground, and <em>p<sub>i</sub></em> indicates the vertical height of one
corner of the left foot.</p>

<p>To compute the gradient of the above objective function, we need to evaluate
the partial derivatives of each objective term with respect to the
degrees of freedom, i.e., the computation of Jacobian matrix. DART
provides a comprensive set of APIs for accessing various types of
Jacobian. In this example, computing the gradient of the first term of
the objective function requires the Jacobian of the
center of mass of the Skeleton, as well as the Jacobian of the center
of mass of a BodyNode:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">solveIK</span><span class="p">(</span><span class="n">SkeletonPtr</span> <span class="n">biped</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">localCOM</span> <span class="o">=</span> <span class="n">leftHeel</span><span class="o">-&gt;</span><span class="n">getCOM</span><span class="p">(</span><span class="n">leftHeel</span><span class="p">);</span>
    <span class="n">LinearJacobian</span> <span class="n">jacobian</span> <span class="o">=</span> <span class="n">biped</span><span class="o">-&gt;</span><span class="n">getCOMLinearJacobian</span><span class="p">()</span> <span class="o">-</span> <span class="n">biped</span><span class="o">-&gt;</span><span class="n">getLinearJacobian</span><span class="p">(</span><span class="n">leftHeel</span><span class="p">,</span> <span class="n">localCOM</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">getCOMLinearJacobian</code> returns the linear Jacobian of the
center of mass of the Skeleton, while <code class="highlighter-rouge">getLinearJacobian</code>
returns the Jacobian of a point on a BodyNode. The BodyNode and the
local coordinate of the point are specified as parameters to this
function. Here the point of interest is the center of mass of the left
foot, which local coordinates can be accessed by <code class="highlighter-rouge">getCOM</code>
with a parameter indicating the left foot being the frame of
reference. We use <code class="highlighter-rouge">getLinearJacobian</code> again to compute the
gradient of the second term of the objective function:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="n">solveIK</span><span class="p">(</span><span class="n">SkeletonPtr</span> <span class="n">biped</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">offset</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.04</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03</span><span class="p">);</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="n">biped</span><span class="o">-&gt;</span><span class="n">getLinearJacobian</span><span class="p">(</span><span class="n">leftHeel</span><span class="p">,</span> <span class="n">offset</span><span class="p">).</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The full list of Jacobian APIs can be found in the <a href="http://dartsim.github.io/dart/">API Documentation</a>. The 
following table summarizes the essential APIs.</p>

<table>
  <thead>
    <tr>
      <th>Function Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>getJacobian</td>
      <td>Return the generalized Jacobian targeting the origin of the BodyNode. The Jacobian is expressed in the Frame of this BodyNode.</td>
    </tr>
    <tr>
      <td>getLinearJacobian</td>
      <td>Return the linear Jacobian targeting the origin of the BodyNode. You can specify a coordinate Frame to express the Jacobian in.</td>
    </tr>
    <tr>
      <td>getAngularJacobian</td>
      <td>Return the angular Jacobian targeting the origin of the BodyNode. You can specify a coordinate Frame to express the Jacobian in.</td>
    </tr>
    <tr>
      <td>getJacobianSpatialDeriv</td>
      <td>Return the spatial time derivative of the generalized Jacobian targeting the origin of the BodyNode. The Jacobian is expressed in the BodyNode’s coordinate Frame.</td>
    </tr>
    <tr>
      <td>getJacobianClassicDeriv</td>
      <td>Return the classical time derivative of the generalized Jacobian targeting the origin of the BodyNode. The Jacobian is expressed in the World coordinate Frame.</td>
    </tr>
    <tr>
      <td>getLinearJacobianDeriv</td>
      <td>Return the linear Jacobian (classical) time derivative, in terms of any coordinate Frame.</td>
    </tr>
    <tr>
      <td>getAngularJacobianDeriv</td>
      <td>Return the angular Jacobian (classical) time derivative, in terms of any coordinate Frame.</td>
    </tr>
  </tbody>
</table>

<p>This Lesson concludes the entire Biped tutorial. You should see a biped
standing stably on the skateboard. With moderate
acceleration/deceleration on the skateboard, the biped is able to
maintain balance and hold the one-foot stance pose.</p>

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like" data-href="http://dart.readthedocs.org/en/release-5.1/tutorials/biped/" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true"></div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'dartsim';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



    <div class="tags">
        
    </div>

    

</div>

<hr class="shaded"/>

<footer>
            <div class="row">
                <div class="col-lg-12 footer">
               &copy;2016 Georgia Tech and Carnegie Mellon University. All rights reserved. <br />
 Site last generated: Oct 6, 2016 <br />
<p><img src="images/dart_logo_big.jpg" alt="DART logo" style="width:128px"/></p>
                </div>
            </div>
</footer>


    </div>
    <!-- /.row -->
</div>
<!-- /.container -->
    </div>

</body>

</html>